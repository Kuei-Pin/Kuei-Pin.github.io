<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">



  
  
    
    
  <script src="/lib/pace/pace.min.js?v=1.0.2"></script>
  <link href="/lib/pace/pace-theme-minimal.min.css?v=1.0.2" rel="stylesheet">







<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="xuguibin, ios" />










<meta name="description" content="SDWebImage让我们在可以像使用本地图片那样非常方便地使用来源于网络的图片，例如我们可以使用UIImageView分类的-sd_setImageWithURL方法，直接传入URL就能显示图片，不需要其它操作。但是在这个过程中，SDWebImage其实会进行很多操作，比如缓存和下载等。如下SDWebImage类图所示，虽然各个类之间的关系有点错(luan)综(de)复(yao)杂(si)，其实">
<meta property="og:type" content="article">
<meta property="og:title" content="读一读SDWebImage4">
<meta property="og:url" content="https://xxxxxxgb.github.io/2018/05/26/SDWebImage/index.html">
<meta property="og:site_name" content="西瓜冰的博客">
<meta property="og:description" content="SDWebImage让我们在可以像使用本地图片那样非常方便地使用来源于网络的图片，例如我们可以使用UIImageView分类的-sd_setImageWithURL方法，直接传入URL就能显示图片，不需要其它操作。但是在这个过程中，SDWebImage其实会进行很多操作，比如缓存和下载等。如下SDWebImage类图所示，虽然各个类之间的关系有点错(luan)综(de)复(yao)杂(si)，其实">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://xxxxxxgb.github.io/images/SDWebImageClassDiagram.png">
<meta property="og:image" content="https://xxxxxxgb.github.io/images/image_format.png">
<meta property="og:updated_time" content="2018-06-22T06:46:37.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="读一读SDWebImage4">
<meta name="twitter:description" content="SDWebImage让我们在可以像使用本地图片那样非常方便地使用来源于网络的图片，例如我们可以使用UIImageView分类的-sd_setImageWithURL方法，直接传入URL就能显示图片，不需要其它操作。但是在这个过程中，SDWebImage其实会进行很多操作，比如缓存和下载等。如下SDWebImage类图所示，虽然各个类之间的关系有点错(luan)综(de)复(yao)杂(si)，其实">
<meta name="twitter:image" content="https://xxxxxxgb.github.io/images/SDWebImageClassDiagram.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.4',
    sidebar: {"position":"left","display":"hide","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://xxxxxxgb.github.io/2018/05/26/SDWebImage/"/>





  <title>读一读SDWebImage4 | 西瓜冰的博客</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?b728f881bd233f20a31842facda5c201";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">西瓜冰的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <h1 class="site-subtitle" itemprop="description"></h1>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>

<script>
    (function(){
        if(''){
            if (prompt('请输入文章密码') !== ''){
                alert('密码错误！');
                history.back();
            }
        }
    })();
</script>

 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://xxxxxxgb.github.io/2018/05/26/SDWebImage/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="西瓜冰的博客">
    </span>

    
      <header class="post-header">

        
        
          <h2 class="post-title" itemprop="name headline">读一读SDWebImage4</h2>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-05-26T17:21:11+08:00">
                2018-05-26
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/源码/" itemprop="url" rel="index">
                    <span itemprop="name">源码</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/26/SDWebImage/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count gitment-comments-count" data-xid="/2018/05/26/SDWebImage/" itemprop="commentsCount"></span>
                </a>
              </span>
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  13,041
                </span>
              

              

              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><code>SDWebImage</code>让我们在可以像使用本地图片那样非常方便地使用来源于网络的图片，例如我们可以使用<code>UIImageView</code>分类的<code>-sd_setImageWithURL</code>方法，直接传入URL就能显示图片，不需要其它操作。但是在这个过程中，<code>SDWebImage</code>其实会进行很多操作，比如缓存和下载等。<br>如下<code>SDWebImage</code>类图所示，虽然各个类之间的关系有点错(luan)综(de)复(yao)杂(si)，其实<code>SDWebImage</code>主要只是由三个模块（图片编解码、缓存和下载）组成，各个模块实现各自的主要功能，这过程中可能需要其它模块的功能，就像公司各部门各司其职但也需要协作。<br><img src="/images/SDWebImageClassDiagram.png" alt="SDWebImage类图"><br>先按照各个模块来读代码，了解各模块的实现，最后在整合来看<code>SDWebImage</code>怎么处理网络图片。<br><a id="more"></a></p>
<h1 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h1><h2 id="SDWebImageFrame"><a href="#SDWebImageFrame" class="headerlink" title="SDWebImageFrame"></a>SDWebImageFrame</h2><p>相当于一个Model类，对动态图片的每一帧图片进行封装。具体结构如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></div><div class="code"><pre><div class="line"><span class="comment">// SDWebImageFrame.h</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageFrame</span> : <span class="title">NSObject</span></span></div><div class="line"><span class="comment">/** 当前帧的图片 */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readonly</span>, <span class="keyword">nonnull</span>) <span class="built_in">UIImage</span> *image;</div><div class="line"><span class="comment">/** 当前帧图片持续的时间，单位秒，而不是毫秒，不能设置为0。 */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readonly</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> duration;</div><div class="line"></div><div class="line"><span class="comment">/** 工厂方法 */</span></div><div class="line">+ (<span class="keyword">instancetype</span> _Nonnull)frameWithImage:(<span class="built_in">UIImage</span> * _Nonnull)image duration:(<span class="built_in">NSTimeInterval</span>)duration;</div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="comment">// SDWebImageFrame.m</span></div><div class="line"><span class="comment">// 将readonly改为readwrite类型，并实现工厂方法</span></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageFrame</span> ()</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">readwrite</span>, <span class="keyword">nonnull</span>) <span class="built_in">UIImage</span> *image;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">readwrite</span>, <span class="keyword">assign</span>) <span class="built_in">NSTimeInterval</span> duration;</div><div class="line"><span class="keyword">@end</span></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDWebImageFrame</span></span></div><div class="line">+ (<span class="keyword">instancetype</span>)frameWithImage:(<span class="built_in">UIImage</span> *)image duration:(<span class="built_in">NSTimeInterval</span>)duration &#123;</div><div class="line">    SDWebImageFrame *frame = [[SDWebImageFrame alloc] init];</div><div class="line">    frame.image = image;</div><div class="line">    frame.duration = duration;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> frame;</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></div></div></figure></p>
<h2 id="SDWebImageCoderHelper"><a href="#SDWebImageCoderHelper" class="headerlink" title="SDWebImageCoderHelper"></a>SDWebImageCoderHelper</h2><p>一个助手类，总共提供了四种辅助方法<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></div><div class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    这方法是给动态图片打上补丁。这个补丁是因为直接使用+[UIImage animatedImageWithImages:duration:]会将每帧动画持续总时间的平均时长。</span></div><div class="line"><span class="comment">    因此当不同帧图片要持续的时间不是相同时，就不能完美地呈现。所以我们需要给特定的每帧图片赋予特定的持续时间。</span></div><div class="line"><span class="comment">*/</span></div><div class="line">+ (<span class="built_in">UIImage</span> * _Nullable)animatedImageWithFrames:(<span class="built_in">NSArray</span>&lt;SDWebImageFrame *&gt; * _Nullable)frames;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    这方法将取消上面描述的补丁并且创建一个帧数组。这方法同样适用于普通的动态图片。</span></div><div class="line"><span class="comment">*/</span></div><div class="line">+ (<span class="built_in">NSArray</span>&lt;SDWebImageFrame *&gt; * _Nullable)framesFromAnimatedImage:(<span class="built_in">UIImage</span> * _Nullable)animatedImage;</div><div class="line"></div><div class="line"><span class="comment">/** 将一个EXIF图片方向转化成iOS系统方向。 */</span></div><div class="line">+ (<span class="built_in">UIImageOrientation</span>)imageOrientationFromEXIFOrientation:(<span class="built_in">NSInteger</span>)exifOrientation;</div><div class="line"></div><div class="line"><span class="comment">/** 将一个iOS系统方向转化成EXIF图片方向。 */</span></div><div class="line">+ (<span class="built_in">NSInteger</span>)exifOrientationFromImageOrientation:(<span class="built_in">UIImageOrientation</span>)imageOrientation;</div></pre></div></div></figure></p>
<p>这四个方法的实现分别如下:<br><strong>+animatedImageWithFrames:</strong><br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></div><div class="code"><pre><div class="line">+ (<span class="built_in">UIImage</span> *)animatedImageWithFrames:(<span class="built_in">NSArray</span>&lt;SDWebImageFrame *&gt; *)frames &#123;</div><div class="line">    <span class="built_in">NSUInteger</span> frameCount = frames.count;</div><div class="line">    <span class="keyword">if</span> (frameCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">UIImage</span> *animatedImage;</div><div class="line">    </div><div class="line">    <span class="built_in">NSUInteger</span> durations[frameCount];</div><div class="line">    <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; frameCount; i++) &#123;</div><div class="line">        durations[i] = frames[i].duration * <span class="number">1000</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// 求数组中所有值的最大公约数</span></div><div class="line">    <span class="built_in">NSUInteger</span> <span class="keyword">const</span> gcd = gcdArray(frameCount, durations);</div><div class="line">    __block <span class="built_in">NSUInteger</span> totalDuration = <span class="number">0</span>;</div><div class="line">    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">UIImage</span> *&gt; *animatedImages = [<span class="built_in">NSMutableArray</span> arrayWithCapacity:frameCount];</div><div class="line">    [frames enumerateObjectsUsingBlock:^(SDWebImageFrame * _Nonnull frame, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">        <span class="built_in">UIImage</span> *image = frame.image;</div><div class="line">        <span class="built_in">NSUInteger</span> duration = frame.duration * <span class="number">1000</span>;</div><div class="line">        totalDuration += duration;</div><div class="line">        <span class="built_in">NSUInteger</span> repeatCount;</div><div class="line">        <span class="keyword">if</span> (gcd) &#123;</div><div class="line">            repeatCount = duration / gcd;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            repeatCount = <span class="number">1</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">for</span> (size_t i = <span class="number">0</span>; i &lt; repeatCount; ++i) &#123;</div><div class="line">            [animatedImages addObject:image];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    </div><div class="line">    animatedImage = [<span class="built_in">UIImage</span> animatedImageWithImages:animatedImages duration:totalDuration / <span class="number">1000.</span>f];</div><div class="line">    <span class="keyword">return</span> animatedImage;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p>上面代码的关键部分是通过求所有帧动画持续时间的最大公约数，再由持续时间/最大公约数求出对相同的图片重复添加的次数。（例如，A图片持续0.6秒，B图片持续0.8秒，它们最大公约数为200毫秒，那么A图片重复添加次数为3，B图片为4，图片数组为[A,A,A,B,B,B,B]。因为总持续时间1.4秒，那么使用<code>+[UIImage animatedImageWithImages:duration:]</code>方法平均后每张图片持续0.2秒，这样就实现了A图片持续0.6秒，B图片持续0.8秒的效果。）此外，<a href="https://blog.csdn.net/linj_m/article/details/19167147" target="_blank" rel="noopener">求最大公约数的方法</a>如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></div><div class="code"><pre><div class="line"><span class="keyword">static</span> <span class="built_in">NSUInteger</span> gcd(<span class="built_in">NSUInteger</span> a, <span class="built_in">NSUInteger</span> b) &#123;</div><div class="line">    <span class="built_in">NSUInteger</span> c;</div><div class="line">    <span class="keyword">while</span> (a != <span class="number">0</span>) &#123;</div><div class="line">        c = a;</div><div class="line">        a = b % a;</div><div class="line">        b = c;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> b;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">static</span> <span class="built_in">NSUInteger</span> gcdArray(size_t <span class="keyword">const</span> count, <span class="built_in">NSUInteger</span> <span class="keyword">const</span> * <span class="keyword">const</span> values) &#123;</div><div class="line">    <span class="keyword">if</span> (count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="number">0</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSUInteger</span> result = values[<span class="number">0</span>];</div><div class="line">    <span class="keyword">for</span> (size_t i = <span class="number">1</span>; i &lt; count; ++i) &#123;</div><div class="line">        result = gcd(values[i], result);</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> result;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p><strong>+framesFromAnimatedImage:</strong><br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></div><div class="code"><pre><div class="line">+ (<span class="built_in">NSArray</span>&lt;SDWebImageFrame *&gt; *)framesFromAnimatedImage:(<span class="built_in">UIImage</span> *)animatedImage &#123;</div><div class="line">    <span class="keyword">if</span> (!animatedImage) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableArray</span>&lt;SDWebImageFrame *&gt; *frames = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    <span class="built_in">NSUInteger</span> frameCount = <span class="number">0</span>;</div><div class="line">    </div><div class="line">    <span class="built_in">NSArray</span>&lt;<span class="built_in">UIImage</span> *&gt; *animatedImages = animatedImage.images;</div><div class="line">    frameCount = animatedImages.count;</div><div class="line">    <span class="keyword">if</span> (frameCount == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSTimeInterval</span> avgDuration = animatedImage.duration / frameCount;</div><div class="line">    <span class="keyword">if</span> (avgDuration == <span class="number">0</span>) &#123;</div><div class="line">        avgDuration = <span class="number">0.1</span>; <span class="comment">// 如果只有图片没有持续时间，那么持续时间默认100ms。 (这不像GIF或者WebP有10ms限制，它允许码农自己定义限制时长。)</span></div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __block <span class="built_in">NSUInteger</span> index = <span class="number">0</span>;</div><div class="line">    __block <span class="built_in">NSUInteger</span> repeatCount = <span class="number">1</span>;</div><div class="line">    __block <span class="built_in">UIImage</span> *previousImage = animatedImages.firstObject;</div><div class="line">    [animatedImages enumerateObjectsUsingBlock:^(<span class="built_in">UIImage</span> * _Nonnull image, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">        <span class="keyword">if</span> (idx == <span class="number">0</span>) &#123;</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ([image isEqual:previousImage]) &#123;</div><div class="line">            repeatCount++;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount];</div><div class="line">            [frames addObject:frame];</div><div class="line">            repeatCount = <span class="number">1</span>;</div><div class="line">            index++;</div><div class="line">        &#125;</div><div class="line">        previousImage = image;</div><div class="line">        <span class="keyword">if</span> (idx == frameCount - <span class="number">1</span>) &#123;</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:previousImage duration:avgDuration * repeatCount];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">    <span class="keyword">return</span> frames;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p>这方法差不多是上面方法的逆过程，通过修改duration将相同图片的帧封装到同一个<code>SDWebImageFrame</code>中。<br>此外，还有两个<a href="https://zh.wikipedia.org/wiki/EXIF" target="_blank" rel="noopener">EXIF</a>（图片的可编辑附加信息）方向和iOS方向相互转换的方法转换的方法，实现都是通过一个简单的switch case。</p>
<h2 id="SDWebImageCoder"><a href="#SDWebImageCoder" class="headerlink" title="SDWebImageCoder"></a>SDWebImageCoder</h2><p>这里主要定义了两个协议接口，这两协议定义的方法都要求实现。<code>SDWebImageCoder</code>定义了一系列编解码的方法，Decoder模块内所有完成具体实现功能的类都遵循并实现该协议所有方法。协议的方法如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></div><div class="code"><pre><div class="line"><span class="comment">/** 是否支持对某种数据格式（例如WebP）的图片的解码 */</span></div><div class="line">- (<span class="built_in">BOOL</span>)canDecodeFromData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data;</div><div class="line"></div><div class="line"><span class="comment">/** 将图片数据解码成图片 */</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)decodedImageWithData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data;</div><div class="line"></div><div class="line"><span class="comment">/** </span></div><div class="line"><span class="comment">    将原始图片或者图片数据进行解压。</span></div><div class="line"><span class="comment">    @param image 要解压的原始图片</span></div><div class="line"><span class="comment">    @param data 指向原始图片的指针。这指针本身不能为空，但指向的图片数据可以为空。如果需要这数据将可能被设置为缓存。如果不需要修改数据，则忽略这个属性。</span></div><div class="line"><span class="comment">    @param optionsDict 使用&#123;SDWebImageCoderScaleDownLargeImagesKey: @(YES)&#125;来设置按比例裁剪大图。</span></div><div class="line"><span class="comment">*/</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)decompressedImageWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</div><div class="line">                                            data:(<span class="built_in">NSData</span> * _Nullable * _Nonnull)data</div><div class="line">                                         options:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span>*, <span class="built_in">NSObject</span>*&gt;*)optionsDict;</div><div class="line">                                         </div><div class="line"><span class="comment">/** 能否解码指定的图片格式 */</span></div><div class="line">- (<span class="built_in">BOOL</span>)canEncodeToFormat:(SDImageFormat)format;</div><div class="line"></div><div class="line"><span class="comment">/** 将图片解码成NSData */</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)encodedDataWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image format:(SDImageFormat)format;</div></pre></div></div></figure></p>
<p><code>SDWebImageProgressiveCoder</code>是<code>SDWebImageCoder</code>的子协议，在其基础上新定义了两个逐步解码图片的方法：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></div><div class="code"><pre><div class="line"><span class="comment">/** 能否逐步解码（慢慢显示）指定的数据 */</span></div><div class="line">- (<span class="built_in">BOOL</span>)canIncrementallyDecodeFromData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data;</div><div class="line"></div><div class="line"><span class="comment">/** 逐步将数据解码成图片 */</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)incrementallyDecodedImageWithData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data finished:(<span class="built_in">BOOL</span>)finished;</div></pre></div></div></figure></p>
<p><code>SDWebImageCoder</code>内部还定义了两个工具方法<code>SDCGColorSpaceGetDeviceRGB</code>用于获取设备的RGB<a href="https://zh.wikipedia.org/wiki/%E8%89%B2%E5%BD%A9%E7%A9%BA%E9%96%93" target="_blank" rel="noopener">色彩空间</a>和<code>SDCGImageRefContainsAlpha</code>方法判断图片是否支持透明度(alpha)。实现如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></div><div class="code"><pre><div class="line"><span class="built_in">CGColorSpaceRef</span> SDCGColorSpaceGetDeviceRGB(<span class="keyword">void</span>) &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">CGColorSpaceRef</span> colorSpace;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> onceToken;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;onceToken, ^&#123;</div><div class="line">        colorSpace = <span class="built_in">CGColorSpaceCreateDeviceRGB</span>();</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> colorSpace;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">BOOL</span> SDCGImageRefContainsAlpha(<span class="built_in">CGImageRef</span> imageRef) &#123;</div><div class="line">    <span class="keyword">if</span> (!imageRef) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">CGImageAlphaInfo</span> alphaInfo = <span class="built_in">CGImageGetAlphaInfo</span>(imageRef);</div><div class="line">    <span class="built_in">BOOL</span> hasAlpha = !(alphaInfo == kCGImageAlphaNone ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipFirst ||</div><div class="line">                      alphaInfo == kCGImageAlphaNoneSkipLast);</div><div class="line">    <span class="keyword">return</span> hasAlpha;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h2 id="SDWebImageImageIOCoder"><a href="#SDWebImageImageIOCoder" class="headerlink" title="SDWebImageImageIOCoder"></a>SDWebImageImageIOCoder</h2><p>这个类可以解码出WebP以外的其他图片类型，该类实现了<code>SDWebImageProgressiveCoder</code>协议也意味着支持这些图片的逐步解析。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></div><div class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageImageIOCoder</span> : <span class="title">NSObject</span> &lt;<span class="title">SDWebImageProgressiveCoder</span>&gt;</span></div><div class="line"></div><div class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedCoder;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></div></div></figure></p>
<p>这个类值得了解的方法是逐步解码方法和图片解压方法，代码如下：<br><strong>逐步解码</strong><br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></div><div class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)incrementallyDecodedImageWithData:(<span class="built_in">NSData</span> *)data finished:(<span class="built_in">BOOL</span>)finished &#123;</div><div class="line">    <span class="keyword">if</span> (!_imageSource) &#123;</div><div class="line">        _imageSource = <span class="built_in">CGImageSourceCreateIncremental</span>(<span class="literal">NULL</span>);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">UIImage</span> *image;</div><div class="line">    </div><div class="line">    <span class="comment">// 生成只包含部分数据的图片</span></div><div class="line">    <span class="built_in">CGImageSourceUpdateData</span>(_imageSource, (__bridge <span class="built_in">CFDataRef</span>)data, finished);</div><div class="line">    </div><div class="line">    <span class="comment">// 第一次解码时获取图片的宽、高和方向的信息。</span></div><div class="line">    <span class="keyword">if</span> (_width + _height == <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">CFDictionaryRef</span> properties = <span class="built_in">CGImageSourceCopyPropertiesAtIndex</span>(_imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">        <span class="keyword">if</span> (properties) &#123;</div><div class="line">            <span class="built_in">NSInteger</span> orientationValue = <span class="number">1</span>;</div><div class="line">            <span class="built_in">CFTypeRef</span> val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelHeight);</div><div class="line">            <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;_height);</div><div class="line">            val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyPixelWidth);</div><div class="line">            <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberLongType, &amp;_width);</div><div class="line">            val = <span class="built_in">CFDictionaryGetValue</span>(properties, kCGImagePropertyOrientation);</div><div class="line">            <span class="keyword">if</span> (val) <span class="built_in">CFNumberGetValue</span>(val, kCFNumberNSIntegerType, &amp;orientationValue);</div><div class="line">            <span class="built_in">CFRelease</span>(properties);</div><div class="line">            </div><div class="line">            <span class="comment">// 当我们使用Core Graphics绘画时，我们丢失方向信息，</span></div><div class="line">            <span class="comment">// 这意味着使用initWithCGIImage方法生成的图片方向有时会不正确。</span></div><div class="line">            <span class="comment">// （不像使用initWithData方法生成图片）所以在这里保存它，并在后面使用它。</span></div><div class="line">            _orientation = [SDWebImageCoderHelper imageOrientationFromEXIFOrientation:orientationValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (_width + _height &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="built_in">CGImageRef</span> partialImageRef = <span class="built_in">CGImageSourceCreateImageAtIndex</span>(_imageSource, <span class="number">0</span>, <span class="literal">NULL</span>);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (partialImageRef) &#123;</div><div class="line">            image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:partialImageRef scale:<span class="number">1</span> orientation:_orientation];</div><div class="line">            <span class="built_in">CGImageRelease</span>(partialImageRef);</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (finished) &#123;</div><div class="line">        <span class="keyword">if</span> (_imageSource) &#123;</div><div class="line">            <span class="built_in">CFRelease</span>(_imageSource);</div><div class="line">            _imageSource = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p>上面代码中最主要的部分是<code>CGImageSourceUpdateData</code>方法，该方法支持使用部分图片数据生成图片，以此来逐步更新解码图片。<br><strong>图片解压</strong><br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></div><div class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)decompressedImageWithImage:(<span class="built_in">UIImage</span> *)image</div><div class="line">                                   data:(<span class="built_in">NSData</span> *__autoreleasing  _Nullable *)data</div><div class="line">                                options:(<span class="keyword">nullable</span> <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span>*, <span class="built_in">NSObject</span>*&gt;*)optionsDict &#123;</div><div class="line">    <span class="built_in">BOOL</span> shouldScaleDown = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">if</span> (optionsDict != <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="built_in">NSNumber</span> *scaleDownLargeImagesOption = <span class="literal">nil</span>;</div><div class="line">        <span class="keyword">if</span> ([optionsDict[SDWebImageCoderScaleDownLargeImagesKey] isKindOfClass:[<span class="built_in">NSNumber</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">            scaleDownLargeImagesOption = (<span class="built_in">NSNumber</span> *)optionsDict[SDWebImageCoderScaleDownLargeImagesKey];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (scaleDownLargeImagesOption != <span class="literal">nil</span>) &#123;</div><div class="line">            shouldScaleDown = [scaleDownLargeImagesOption boolValue];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (!shouldScaleDown) &#123;</div><div class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> sd_decompressedImageWithImage:image];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">UIImage</span> *scaledDownImage = [<span class="keyword">self</span> sd_decompressedAndScaledDownImageWithImage:image];</div><div class="line">        <span class="keyword">if</span> (scaledDownImage &amp;&amp; !<span class="built_in">CGSizeEqualToSize</span>(scaledDownImage.size, image.size)) &#123;</div><div class="line">            <span class="comment">// if the image is scaled down, need to modify the data pointer as well</span></div><div class="line">            SDImageFormat format = [<span class="built_in">NSData</span> sd_imageFormatForImageData:*data];</div><div class="line">            <span class="built_in">NSData</span> *imageData = [<span class="keyword">self</span> encodedDataWithImage:scaledDownImage format:format];</div><div class="line">            <span class="keyword">if</span> (imageData) &#123;</div><div class="line">                *data = imageData;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> scaledDownImage;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p>在该方法中，根据是否需要按照比例裁剪分别用<code>sd_decompressedImageWithImage</code>和<code>sd_decompressedAndScaledDownImageWithImage</code>来进行具体的处理。<br><code>sd_decompressedImageWithImage</code>解压图片的方式就是将图片绘制到CGContextRef再由这个上下文生成解压后的图片(更多iOS图片解压处理的知识可以在<a href="https://github.com/path/FastImageCache#how-fast-image-cache-works" target="_blank" rel="noopener">这里</a>了解)，代码如下。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)sd_decompressedImageWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</div><div class="line">    <span class="comment">// shouldDecodeImage方法判断图片是否存在以及是否是单张图片(images为nil)</span></div><div class="line">    <span class="keyword">if</span> (![[<span class="keyword">self</span> <span class="keyword">class</span>] shouldDecodeImage:image]) &#123;</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 因为图片所占内存较多，所以使用后即释放内存，不要等到runloop结束再释放。</span></div><div class="line">    <span class="keyword">@autoreleasepool</span>&#123;</div><div class="line">        </div><div class="line">        <span class="built_in">CGImageRef</span> imageRef = image.CGImage;</div><div class="line">        <span class="comment">// device color space</span></div><div class="line">        <span class="built_in">CGColorSpaceRef</span> colorspaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">        <span class="built_in">BOOL</span> hasAlpha = SDCGImageRefContainsAlpha(imageRef);</div><div class="line">        <span class="comment">// iOS display alpha info (BRGA8888/BGRX8888)</span></div><div class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</div><div class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</div><div class="line">        </div><div class="line">        size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</div><div class="line">        size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</div><div class="line">        </div><div class="line">        <span class="comment">// kCGImageAlphaNone is not supported in CGBitmapContextCreate.</span></div><div class="line">        <span class="comment">// Since the original image here has no alpha info, use kCGImageAlphaNoneSkipLast</span></div><div class="line">        <span class="comment">// to create bitmap graphics contexts without alpha info.</span></div><div class="line">        <span class="built_in">CGContextRef</span> context = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</div><div class="line">                                                     width,</div><div class="line">                                                     height,</div><div class="line">                                                     kBitsPerComponent,</div><div class="line">                                                     <span class="number">0</span>,</div><div class="line">                                                     colorspaceRef,</div><div class="line">                                                     bitmapInfo);</div><div class="line">        <span class="keyword">if</span> (context == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> image;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// Draw the image into the context and +6 the new bitmap image without alpha</span></div><div class="line">        <span class="built_in">CGContextDrawImage</span>(context, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</div><div class="line">        <span class="built_in">CGImageRef</span> imageRefWithoutAlpha = <span class="built_in">CGBitmapContextCreateImage</span>(context);</div><div class="line">        <span class="built_in">UIImage</span> *imageWithoutAlpha = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:imageRefWithoutAlpha scale:image.scale orientation:image.imageOrientation];</div><div class="line">        <span class="built_in">CGContextRelease</span>(context);</div><div class="line">        <span class="built_in">CGImageRelease</span>(imageRefWithoutAlpha);</div><div class="line">        </div><div class="line">        <span class="keyword">return</span> imageWithoutAlpha;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p><code>sd_decompressedAndScaledDownImageWithImage</code>方法所做的事情比较复杂，因为在内存不是很充足的情况下直接加载大图片可能会出现问题，所以需要采用分片加载的方式来加载并按比例缩小大图片。这一部分的代码SDWebImage主要参考自<a href="https://developer.apple.com/library/ios/samplecode/LargeImageDownsizing/" target="_blank" rel="noopener">苹果官方栗子</a>。SDWebImage在默认情况下将解压后内存占60M以上的图片定义为大图片，每个切片大小定义为20M，可根据需要修改。具体实现代码如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)sd_decompressedAndScaledDownImageWithImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image &#123;</div><div class="line">    <span class="keyword">if</span> (![[<span class="keyword">self</span> <span class="keyword">class</span>] shouldDecodeImage:image]) &#123;</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 判断是否符合大图片标准。</span></div><div class="line">    <span class="keyword">if</span> (![[<span class="keyword">self</span> <span class="keyword">class</span>] shouldScaleDownImage:image]) &#123;</div><div class="line">        <span class="keyword">return</span> [<span class="keyword">self</span> sd_decompressedImageWithImage:image];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">CGContextRef</span> destContext;</div><div class="line">    </div><div class="line">    <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">        <span class="built_in">CGImageRef</span> sourceImageRef = image.CGImage;</div><div class="line">        </div><div class="line">        <span class="built_in">CGSize</span> sourceResolution = <span class="built_in">CGSizeZero</span>;</div><div class="line">        sourceResolution.width = <span class="built_in">CGImageGetWidth</span>(sourceImageRef);</div><div class="line">        sourceResolution.height = <span class="built_in">CGImageGetHeight</span>(sourceImageRef);</div><div class="line">        <span class="keyword">float</span> sourceTotalPixels = sourceResolution.width * sourceResolution.height;</div><div class="line">        <span class="comment">// 根据原图的尺寸决定要拉伸的比率。定义的最大图片内存大小（不是压缩后的文件大小）为60M。</span></div><div class="line">        <span class="keyword">float</span> imageScale = kDestTotalPixels / sourceTotalPixels;</div><div class="line">        <span class="built_in">CGSize</span> destResolution = <span class="built_in">CGSizeZero</span>;</div><div class="line">        destResolution.width = (<span class="keyword">int</span>)(sourceResolution.width*imageScale);</div><div class="line">        destResolution.height = (<span class="keyword">int</span>)(sourceResolution.height*imageScale);</div><div class="line">        </div><div class="line">        <span class="comment">// device color space</span></div><div class="line">        <span class="built_in">CGColorSpaceRef</span> colorspaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">        <span class="built_in">BOOL</span> hasAlpha = SDCGImageRefContainsAlpha(sourceImageRef);</div><div class="line">        <span class="comment">// iOS display alpha info (BGRA8888/BGRX8888)</span></div><div class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Host;</div><div class="line">        bitmapInfo |= hasAlpha ? kCGImageAlphaPremultipliedFirst : kCGImageAlphaNoneSkipFirst;</div><div class="line">        </div><div class="line">        destContext = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>,</div><div class="line">                                            destResolution.width,</div><div class="line">                                            destResolution.height,</div><div class="line">                                            kBitsPerComponent,</div><div class="line">                                            <span class="number">0</span>,</div><div class="line">                                            colorspaceRef,</div><div class="line">                                            bitmapInfo);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (destContext == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> image;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">CGContextSetInterpolationQuality</span>(destContext, kCGInterpolationHigh);</div><div class="line">        </div><div class="line">        <span class="comment">// 现在定义一个矩形的大小，用于将输入图片的图像数据逐步移到输出图片。</span></div><div class="line">        <span class="comment">// 我们使用一个宽和源图片一样的图片切片是由iOS系统从硬盘中读取图片的方式决定的。</span></div><div class="line">        <span class="comment">// iOS从硬盘解码图片必须以全宽的band进行，即现在将图片上下文按照全宽band裁剪成一个个子矩形。</span></div><div class="line">        <span class="built_in">CGRect</span> sourceTile = <span class="built_in">CGRectZero</span>;</div><div class="line">        sourceTile.size.width = sourceResolution.width;</div><div class="line">        <span class="comment">// 高度是由宽度动态决定的。指定每次读取图片切片的大小，再由这个大小和图片宽度来决定切片高度。</span></div><div class="line">        sourceTile.size.height = (<span class="keyword">int</span>)(kTileTotalPixels / sourceTile.size.width );</div><div class="line">        sourceTile.origin.x = <span class="number">0.0</span>f;</div><div class="line">        </div><div class="line">        <span class="built_in">CGRect</span> destTile;</div><div class="line">        destTile.size.width = destResolution.width;</div><div class="line">        destTile.size.height = sourceTile.size.height * imageScale;</div><div class="line">        destTile.origin.x = <span class="number">0.0</span>f;</div><div class="line">        <span class="comment">// 为了让图片看起来完整地连在一起需要在各个切片之间有一点点部分重跌。</span></div><div class="line">        <span class="comment">// 所以设定重叠部分的高度。源图片的像素需要按比例设置。</span></div><div class="line">        <span class="keyword">float</span> sourceSeemOverlap = (<span class="keyword">int</span>)((kDestSeemOverlap/destResolution.height)*sourceResolution.height);</div><div class="line">        <span class="built_in">CGImageRef</span> sourceTileImageRef;</div><div class="line">        <span class="comment">// 计算合成图片时需要进行的读写操作的次数。</span></div><div class="line">        <span class="keyword">int</span> iterations = (<span class="keyword">int</span>)( sourceResolution.height / sourceTile.size.height );</div><div class="line">        <span class="comment">// 如果不能刚好平方整个图片（即有剩余高度较小的图片切片）则需要+1</span></div><div class="line">        <span class="keyword">int</span> remainder = (<span class="keyword">int</span>)sourceResolution.height % (<span class="keyword">int</span>)sourceTile.size.height;</div><div class="line">        <span class="keyword">if</span>(remainder) &#123;</div><div class="line">            iterations++;</div><div class="line">        &#125;</div><div class="line">        <span class="comment">// 接下来就是读出一个个切片再按比例缩小后拼接成新图片。</span></div><div class="line">        <span class="keyword">float</span> sourceTileHeightMinusOverlap = sourceTile.size.height;</div><div class="line">        sourceTile.size.height += sourceSeemOverlap;</div><div class="line">        destTile.size.height += kDestSeemOverlap;</div><div class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> y = <span class="number">0</span>; y &lt; iterations; ++y ) &#123;</div><div class="line">            <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">                sourceTile.origin.y = y * sourceTileHeightMinusOverlap + sourceSeemOverlap;</div><div class="line">                destTile.origin.y = destResolution.height - (( y + <span class="number">1</span> ) * sourceTileHeightMinusOverlap * imageScale + kDestSeemOverlap);</div><div class="line">                sourceTileImageRef = <span class="built_in">CGImageCreateWithImageInRect</span>( sourceImageRef, sourceTile );</div><div class="line">                <span class="keyword">if</span>( y == iterations - <span class="number">1</span> &amp;&amp; remainder ) &#123;</div><div class="line">                    <span class="keyword">float</span> dify = destTile.size.height;</div><div class="line">                    destTile.size.height = <span class="built_in">CGImageGetHeight</span>( sourceTileImageRef ) * imageScale;</div><div class="line">                    dify -= destTile.size.height;</div><div class="line">                    destTile.origin.y += dify;</div><div class="line">                &#125;</div><div class="line">                <span class="built_in">CGContextDrawImage</span>( destContext, destTile, sourceTileImageRef );</div><div class="line">                <span class="built_in">CGImageRelease</span>( sourceTileImageRef );</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">CGImageRef</span> destImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(destContext);</div><div class="line">        <span class="built_in">CGContextRelease</span>(destContext);</div><div class="line">        <span class="keyword">if</span> (destImageRef == <span class="literal">NULL</span>) &#123;</div><div class="line">            <span class="keyword">return</span> image;</div><div class="line">        &#125;</div><div class="line">        <span class="built_in">UIImage</span> *destImage = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:destImageRef scale:image.scale orientation:image.imageOrientation];</div><div class="line">        <span class="built_in">CGImageRelease</span>(destImageRef);</div><div class="line">        <span class="keyword">if</span> (destImage == <span class="literal">nil</span>) &#123;</div><div class="line">            <span class="keyword">return</span> image;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> destImage;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p><code>SDWebImageImageIOCoder</code>对图片的编码方式是使用<code>CGImageDestinationRef</code>来生成相应格式的图片编码数据，代码如下。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></div><div class="code"><pre><div class="line">- (<span class="built_in">NSData</span> *)encodedDataWithImage:(<span class="built_in">UIImage</span> *)image format:(SDImageFormat)format &#123;</div><div class="line">    <span class="keyword">if</span> (!image) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (format == SDImageFormatUndefined) &#123;</div><div class="line">        <span class="built_in">BOOL</span> hasAlpha = SDCGImageRefContainsAlpha(image.CGImage);</div><div class="line">        <span class="keyword">if</span> (hasAlpha) &#123;</div><div class="line">            format = SDImageFormatPNG;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            format = SDImageFormatJPEG;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableData</span> *imageData = [<span class="built_in">NSMutableData</span> data];</div><div class="line">    <span class="built_in">CFStringRef</span> imageUTType = [<span class="built_in">NSData</span> sd_UTTypeFromSDImageFormat:format];</div><div class="line">    </div><div class="line">    <span class="comment">// Create an image destination.</span></div><div class="line">    <span class="built_in">CGImageDestinationRef</span> imageDestination = <span class="built_in">CGImageDestinationCreateWithData</span>((__bridge <span class="built_in">CFMutableDataRef</span>)imageData, imageUTType, <span class="number">1</span>, <span class="literal">NULL</span>);</div><div class="line">    <span class="keyword">if</span> (!imageDestination) &#123;</div><div class="line">        <span class="comment">// Handle failure.</span></div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableDictionary</span> *properties = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">    <span class="built_in">NSInteger</span> exifOrientation = [SDWebImageCoderHelper exifOrientationFromImageOrientation:image.imageOrientation];</div><div class="line">    [properties setValue:@(exifOrientation) forKey:(__bridge_transfer <span class="built_in">NSString</span> *)kCGImagePropertyOrientation];</div><div class="line">    </div><div class="line">    <span class="comment">// Add your image to the destination.</span></div><div class="line">    <span class="built_in">CGImageDestinationAddImage</span>(imageDestination, image.CGImage, (__bridge <span class="built_in">CFDictionaryRef</span>)properties);</div><div class="line">    </div><div class="line">    <span class="comment">// Finalize the destination.</span></div><div class="line">    <span class="keyword">if</span> (<span class="built_in">CGImageDestinationFinalize</span>(imageDestination) == <span class="literal">NO</span>) &#123;</div><div class="line">        <span class="comment">// Handle failure.</span></div><div class="line">        imageData = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">CFRelease</span>(imageDestination);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> [imageData <span class="keyword">copy</span>];</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h2 id="SDWebImageWebPCoder"><a href="#SDWebImageWebPCoder" class="headerlink" title="SDWebImageWebPCoder"></a>SDWebImageWebPCoder</h2><p><code>SDWebImageWebPCoder</code>是专门用于解码WebP格式图片的类。该类也实现了<code>SDWebImageProgressiveCoder</code>协议，支持WebP的图片解码和逐步解码。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></div><div class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageWebPCoder</span> : <span class="title">NSObject</span> &lt;<span class="title">SDWebImageProgressiveCoder</span>&gt;</span></div><div class="line"></div><div class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedCoder;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></div></div></figure></p>
<p>该类对图片的解码主要是通过<a href="https://github.com/webmproject/libwebp" target="_blank" rel="noopener">libwebp</a>来解码图片数据，然后再把位图数据绘制成图片，代码如下。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div></pre></div><div class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)decodedImageWithData:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    <span class="keyword">if</span> (!data) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    WebPData webpData;</div><div class="line">    WebPDataInit(&amp;webpData);</div><div class="line">    webpData.bytes = data.bytes;</div><div class="line">    webpData.size = data.length;</div><div class="line">    WebPDemuxer *demuxer = WebPDemux(&amp;webpData);</div><div class="line">    <span class="keyword">if</span> (!demuxer) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    uint32_t flags = WebPDemuxGetI(demuxer, WEBP_FF_FORMAT_FLAGS);</div><div class="line">    <span class="keyword">int</span> loopCount = WebPDemuxGetI(demuxer, WEBP_FF_LOOP_COUNT);</div><div class="line">    <span class="keyword">int</span> canvasWidth = WebPDemuxGetI(demuxer, WEBP_FF_CANVAS_WIDTH);</div><div class="line">    <span class="keyword">int</span> canvasHeight = WebPDemuxGetI(demuxer, WEBP_FF_CANVAS_HEIGHT);</div><div class="line">    <span class="built_in">CGBitmapInfo</span> bitmapInfo;</div><div class="line">    <span class="keyword">if</span> (!(flags &amp; ALPHA_FLAG)) &#123;</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaNoneSkipLast;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">CGContextRef</span> canvas = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, canvasWidth, canvasHeight, <span class="number">8</span>, <span class="number">0</span>, SDCGColorSpaceGetDeviceRGB(), bitmapInfo);</div><div class="line">    <span class="keyword">if</span> (!canvas) &#123;</div><div class="line">        WebPDemuxDelete(demuxer);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (!(flags &amp; ANIMATION_FLAG)) &#123;</div><div class="line">        <span class="comment">// 单张静态图片</span></div><div class="line">        <span class="built_in">UIImage</span> *staticImage = [<span class="keyword">self</span> sd_rawWebpImageWithData:webpData];</div><div class="line">        <span class="keyword">if</span> (staticImage) &#123;</div><div class="line">            <span class="comment">// draw on CGBitmapContext can reduce memory usage</span></div><div class="line">            <span class="built_in">CGImageRef</span> imageRef = staticImage.CGImage;</div><div class="line">            size_t width = <span class="built_in">CGImageGetWidth</span>(imageRef);</div><div class="line">            size_t height = <span class="built_in">CGImageGetHeight</span>(imageRef);</div><div class="line">            <span class="built_in">CGContextDrawImage</span>(canvas, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, <span class="number">0</span>, width, height), imageRef);</div><div class="line">            <span class="built_in">CGImageRef</span> newImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(canvas);</div><div class="line">            staticImage = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:newImageRef];</div><div class="line">            <span class="built_in">CGImageRelease</span>(newImageRef);</div><div class="line">        &#125;</div><div class="line">        WebPDemuxDelete(demuxer);</div><div class="line">        <span class="built_in">CGContextRelease</span>(canvas);</div><div class="line">        <span class="keyword">return</span> staticImage;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 动态图片</span></div><div class="line">    WebPIterator iter;</div><div class="line">    <span class="keyword">if</span> (!WebPDemuxGetFrame(demuxer, <span class="number">1</span>, &amp;iter)) &#123;</div><div class="line">        WebPDemuxReleaseIterator(&amp;iter);</div><div class="line">        WebPDemuxDelete(demuxer);</div><div class="line">        <span class="built_in">CGContextRelease</span>(canvas);</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSMutableArray</span>&lt;SDWebImageFrame *&gt; *frames = [<span class="built_in">NSMutableArray</span> array];</div><div class="line">    </div><div class="line">    <span class="keyword">do</span> &#123;</div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">            <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> sd_drawnWebpImageWithCanvas:canvas iterator:iter];</div><div class="line">            <span class="keyword">if</span> (!image) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">int</span> duration = iter.duration;</div><div class="line">            <span class="keyword">if</span> (duration &lt;= <span class="number">10</span>) &#123;</div><div class="line">                <span class="comment">// WebP standard says 0 duration is used for canvas updating but not showing image, but actually Chrome and other implementations set it to 100ms if duration is lower or equal than 10ms</span></div><div class="line">                <span class="comment">// Some animated WebP images also created without duration, we should keep compatibility</span></div><div class="line">                duration = <span class="number">100</span>;</div><div class="line">            &#125;</div><div class="line">            SDWebImageFrame *frame = [SDWebImageFrame frameWithImage:image duration:duration / <span class="number">1000.</span>f];</div><div class="line">            [frames addObject:frame];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">    &#125; <span class="keyword">while</span> (WebPDemuxNextFrame(&amp;iter));</div><div class="line">    </div><div class="line">    WebPDemuxReleaseIterator(&amp;iter);</div><div class="line">    WebPDemuxDelete(demuxer);</div><div class="line">    <span class="built_in">CGContextRelease</span>(canvas);</div><div class="line">    </div><div class="line">    <span class="built_in">UIImage</span> *animatedImage = [SDWebImageCoderHelper animatedImageWithFrames:frames];</div><div class="line">    animatedImage.sd_imageLoopCount = loopCount;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> animatedImage;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p>WebP对于单张静态图片的绘制是使用<code>sd_rawWebpImageWithData</code>方法来完成。主要步骤就是使用libwebp解码后的数据创建一个<code>CGDataProviderRef</code>对象，再用<code>CGImageCreate</code>方法创建图片，代码如下。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)sd_rawWebpImageWithData:(WebPData)webpData &#123;</div><div class="line">    WebPDecoderConfig config;</div><div class="line">    <span class="keyword">if</span> (!WebPInitDecoderConfig(&amp;config)) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (WebPGetFeatures(webpData.bytes, webpData.size, &amp;config.input) != VP8_STATUS_OK) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    config.output.colorspace = config.input.has_alpha ? MODE_rgbA : MODE_RGB;</div><div class="line">    config.options.use_threads = <span class="number">1</span>;</div><div class="line">    </div><div class="line">    <span class="comment">// Decode the WebP image data into a RGBA value array</span></div><div class="line">    <span class="keyword">if</span> (WebPDecode(webpData.bytes, webpData.size, &amp;config) != VP8_STATUS_OK) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> width = config.input.width;</div><div class="line">    <span class="keyword">int</span> height = config.input.height;</div><div class="line">    <span class="keyword">if</span> (config.options.use_scaling) &#123;</div><div class="line">        width = config.options.scaled_width;</div><div class="line">        height = config.options.scaled_height;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// Construct a UIImage from the decoded RGBA value array</span></div><div class="line">    <span class="built_in">CGDataProviderRef</span> provider =</div><div class="line">    <span class="built_in">CGDataProviderCreateWithData</span>(<span class="literal">NULL</span>, config.output.u.RGBA.rgba, config.output.u.RGBA.size, FreeImageData);</div><div class="line">    <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">    <span class="built_in">CGBitmapInfo</span> bitmapInfo = config.input.has_alpha ? kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast : kCGBitmapByteOrder32Big | kCGImageAlphaNoneSkipLast;</div><div class="line">    size_t components = config.input.has_alpha ? <span class="number">4</span> : <span class="number">3</span>;</div><div class="line">    <span class="built_in">CGColorRenderingIntent</span> renderingIntent = kCGRenderingIntentDefault;</div><div class="line">    <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGImageCreate</span>(width, height, <span class="number">8</span>, components * <span class="number">8</span>, components * width, colorSpaceRef, bitmapInfo, provider, <span class="literal">NULL</span>, <span class="literal">NO</span>, renderingIntent);</div><div class="line">    </div><div class="line">    <span class="built_in">CGDataProviderRelease</span>(provider);</div><div class="line">    </div><div class="line">    <span class="built_in">UIImage</span> *image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:imageRef];</div><div class="line">    </div><div class="line">    <span class="built_in">CGImageRelease</span>(imageRef);</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p>动态WebP的原理与GIF和APNG原理类似，每一帧记录变化区域的坐标、长宽、播放延时等用于还原并播放。所以绘制每一帧图片时根据当前帧是否是混合的以及当前帧数据的偏移量来绘制，代码如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)sd_drawnWebpImageWithCanvas:(<span class="built_in">CGContextRef</span>)canvas iterator:(WebPIterator)iter &#123;</div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> sd_rawWebpImageWithData:iter.fragment];</div><div class="line">    <span class="keyword">if</span> (!image) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    size_t canvasWidth = <span class="built_in">CGBitmapContextGetWidth</span>(canvas);</div><div class="line">    size_t canvasHeight = <span class="built_in">CGBitmapContextGetHeight</span>(canvas);</div><div class="line">    <span class="built_in">CGSize</span> size = <span class="built_in">CGSizeMake</span>(canvasWidth, canvasHeight);</div><div class="line">    <span class="built_in">CGFloat</span> tmpX = iter.x_offset;</div><div class="line">    <span class="built_in">CGFloat</span> tmpY = size.height - iter.height - iter.y_offset;</div><div class="line">    <span class="built_in">CGRect</span> imageRect = <span class="built_in">CGRectMake</span>(tmpX, tmpY, iter.width, iter.height);</div><div class="line">    <span class="built_in">BOOL</span> shouldBlend = iter.blend_method == WEBP_MUX_BLEND;</div><div class="line">    </div><div class="line">    <span class="comment">// If not blend, cover the target image rect. (firstly clear then draw)</span></div><div class="line">    <span class="keyword">if</span> (!shouldBlend) &#123;</div><div class="line">        <span class="built_in">CGContextClearRect</span>(canvas, imageRect);</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">CGContextDrawImage</span>(canvas, imageRect, image.CGImage);</div><div class="line">    <span class="built_in">CGImageRef</span> newImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(canvas);</div><div class="line">    </div><div class="line">    image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:newImageRef];</div><div class="line">    </div><div class="line">    <span class="built_in">CGImageRelease</span>(newImageRef);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (iter.dispose_method == WEBP_MUX_DISPOSE_BACKGROUND) &#123;</div><div class="line">        <span class="built_in">CGContextClearRect</span>(canvas, imageRect);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<hr>
<p>在逐步解码方法上，因为WebP有对当前部分图片数据进行解析的API，所以直接使用API计算出当前解码部分，再进行图片绘制，代码如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div></pre></div><div class="code"><pre><div class="line">- (<span class="built_in">UIImage</span> *)incrementallyDecodedImageWithData:(<span class="built_in">NSData</span> *)data finished:(<span class="built_in">BOOL</span>)finished &#123;</div><div class="line">    <span class="keyword">if</span> (!_idec) &#123;</div><div class="line">        <span class="comment">// Progressive images need transparent, so always use premultiplied RGBA</span></div><div class="line">        _idec = WebPINewRGB(MODE_rgbA, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="number">0</span>);</div><div class="line">        <span class="keyword">if</span> (!_idec) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">UIImage</span> *image;</div><div class="line">    </div><div class="line">    VP8StatusCode status = WebPIUpdate(_idec, data.bytes, data.length);</div><div class="line">    <span class="keyword">if</span> (status != VP8_STATUS_OK &amp;&amp; status != VP8_STATUS_SUSPENDED) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">int</span> width = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> height = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> last_y = <span class="number">0</span>;</div><div class="line">    <span class="keyword">int</span> stride = <span class="number">0</span>;</div><div class="line">    uint8_t *rgba = WebPIDecGetRGB(_idec, &amp;last_y, &amp;width, &amp;height, &amp;stride);</div><div class="line">    <span class="comment">// last_y may be 0, means no enough bitmap data to decode, ignore this</span></div><div class="line">    <span class="keyword">if</span> (width + height &gt; <span class="number">0</span> &amp;&amp; last_y &gt; <span class="number">0</span> &amp;&amp; height &gt;= last_y) &#123;</div><div class="line">        <span class="comment">// Construct a UIImage from the decoded RGBA value array</span></div><div class="line">        size_t rgbaSize = last_y * stride;</div><div class="line">        <span class="built_in">CGDataProviderRef</span> provider =</div><div class="line">        <span class="built_in">CGDataProviderCreateWithData</span>(<span class="literal">NULL</span>, rgba, rgbaSize, <span class="literal">NULL</span>);</div><div class="line">        <span class="built_in">CGColorSpaceRef</span> colorSpaceRef = SDCGColorSpaceGetDeviceRGB();</div><div class="line">        </div><div class="line">        <span class="built_in">CGBitmapInfo</span> bitmapInfo = kCGBitmapByteOrder32Big | kCGImageAlphaPremultipliedLast;</div><div class="line">        size_t components = <span class="number">4</span>;</div><div class="line">        <span class="built_in">CGColorRenderingIntent</span> renderingIntent = kCGRenderingIntentDefault;</div><div class="line"></div><div class="line">        <span class="built_in">CGImageRef</span> imageRef = <span class="built_in">CGImageCreate</span>(width, last_y, <span class="number">8</span>, components * <span class="number">8</span>, components * width, colorSpaceRef, bitmapInfo, provider, <span class="literal">NULL</span>, <span class="literal">NO</span>, renderingIntent);</div><div class="line">        </div><div class="line">        <span class="built_in">CGDataProviderRelease</span>(provider);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!imageRef) &#123;</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">CGContextRef</span> canvas = <span class="built_in">CGBitmapContextCreate</span>(<span class="literal">NULL</span>, width, height, <span class="number">8</span>, <span class="number">0</span>, SDCGColorSpaceGetDeviceRGB(), bitmapInfo);</div><div class="line">        <span class="keyword">if</span> (!canvas) &#123;</div><div class="line">            <span class="built_in">CGImageRelease</span>(imageRef);</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// Only draw the last_y image height, keep remains transparent, in Core Graphics coordinate system</span></div><div class="line">        <span class="built_in">CGContextDrawImage</span>(canvas, <span class="built_in">CGRectMake</span>(<span class="number">0</span>, height - last_y, width, last_y), imageRef);</div><div class="line">        <span class="built_in">CGImageRef</span> newImageRef = <span class="built_in">CGBitmapContextCreateImage</span>(canvas);</div><div class="line">        <span class="built_in">CGImageRelease</span>(imageRef);</div><div class="line">        <span class="keyword">if</span> (!newImageRef) &#123;</div><div class="line">            <span class="built_in">CGContextRelease</span>(canvas);</div><div class="line">            <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        image = [[<span class="built_in">UIImage</span> alloc] initWithCGImage:newImageRef];</div><div class="line"></div><div class="line">        <span class="built_in">CGImageRelease</span>(newImageRef);</div><div class="line">        <span class="built_in">CGContextRelease</span>(canvas);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (finished) &#123;</div><div class="line">        <span class="keyword">if</span> (_idec) &#123;</div><div class="line">            WebPIDelete(_idec);</div><div class="line">            _idec = <span class="literal">NULL</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h1 id="Cache"><a href="#Cache" class="headerlink" title="Cache"></a>Cache</h1><h2 id="SDImageCacheConfig"><a href="#SDImageCacheConfig" class="headerlink" title="SDImageCacheConfig"></a>SDImageCacheConfig</h2><p>一个Model类，存储着缓存的相关配置，如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></div><div class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDImageCacheConfig</span> : <span class="title">NSObject</span></span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    是否解压下载和缓存的图片，这样做可以改善性能但是会消耗更多内存。</span></div><div class="line"><span class="comment">    默认为YES。当因为内存过大消耗问题导致应用崩溃时，需设置为NO。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDecompressImages;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    禁止iCloud备份。默认YES。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldDisableiCloud;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">   使用内存来进行缓存。默认YES。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">BOOL</span> shouldCacheImagesInMemory;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The reading options while reading cache from disk.</span></div><div class="line"><span class="comment"> * Defaults to 0. You can set this to `NSDataReadingMappedIfSafe` to improve performance.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSDataReadingOptions</span> diskCacheReadingOptions;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * The writing options while writing cache to disk.</span></div><div class="line"><span class="comment"> * Defaults to `NSDataWritingAtomic`. You can set this to `NSDataWritingWithoutOverwriting` to prevent overwriting an existing file.</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSDataWritingOptions</span> diskCacheWritingOptions;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    最大保存时间，单位秒。默认一周。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSInteger</span> maxCacheAge;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    缓存的最大尺寸，单位bytes。</span></div><div class="line"><span class="comment">*/</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxCacheSize;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></div></div></figure></p>
<h2 id="SDImageCache"><a href="#SDImageCache" class="headerlink" title="SDImageCache"></a>SDImageCache</h2><p><code>SDImageCache</code>可以使用内存缓存和磁盘缓存两种方式来对图片进行缓存，默认情况下是同时使用两种缓存，可以通过<code>SDImageCacheConfig</code>来设置是否使用内存缓存。<code>SDImageCache</code>的API主要是一套对缓存的增删查的操作，后面直接看其内部实现，它的公开的属性如下:<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></div><div class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    缓存配置。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDImageCacheConfig *config;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">   最大使用的内存大小。主要消耗取决于内存中保存像素的数量。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxMemoryCost;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    内存最大保存的对象数量。</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>) <span class="built_in">NSUInteger</span> maxMemoryCountLimit;</div></pre></div></div></figure></p>
<h3 id="初始化方法"><a href="#初始化方法" class="headerlink" title="初始化方法"></a>初始化方法</h3><p>初始化方法主要有两个，直接使用单例或者自己定义命名空间和目录来创建<code>SDImageCache</code>。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></div><div class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment">    单例，默认使用"default"的命名空间。</span></div><div class="line"><span class="comment"> */</span></div><div class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedImageCache;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 用指定的命名空间和路径初始化缓存对象。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param ns        命名空间。（与保存图片的文件夹名相关）</span></div><div class="line"><span class="comment"> * @param directory 保存的目录，nil时保存在Library/Cache目录下。</span></div><div class="line"><span class="comment"> */</span></div><div class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithNamespace:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)ns</div><div class="line">                       diskCacheDirectory:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)directory <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div></pre></div></div></figure></p>
<p>实现如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div></pre></div><div class="code"><pre><div class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedImageCache &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</div><div class="line">        instance = [<span class="keyword">self</span> new];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithNamespace:<span class="string">@"default"</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithNamespace:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)ns</div><div class="line">                       diskCacheDirectory:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)directory &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        <span class="built_in">NSString</span> *fullNamespace = [<span class="string">@"com.hackemist.SDWebImageCache."</span> stringByAppendingString:ns];</div><div class="line">        </div><div class="line">        <span class="comment">// 用串行队列进行IO操作，保证不影响主线程UI操作和数据的线程安全。</span></div><div class="line">        _ioQueue = dispatch_queue_create(<span class="string">"com.hackemist.SDWebImageCache"</span>, DISPATCH_QUEUE_SERIAL);</div><div class="line">        </div><div class="line">        _config = [[SDImageCacheConfig alloc] init];</div><div class="line">        </div><div class="line">        <span class="comment">// 初始化内存缓存对象。</span></div><div class="line">        _memCache = [[SDMemoryCache alloc] init];</div><div class="line">        _memCache.name = fullNamespace;</div><div class="line"></div><div class="line">        <span class="comment">// 根据ns和directory设置图片保存文件夹目录。</span></div><div class="line">        <span class="keyword">if</span> (directory != <span class="literal">nil</span>) &#123;</div><div class="line">            _diskCachePath = [directory stringByAppendingPathComponent:fullNamespace];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="built_in">NSString</span> *path = [<span class="keyword">self</span> makeDiskCachePath:ns];</div><div class="line">            _diskCachePath = path;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">dispatch_sync</span>(_ioQueue, ^&#123;</div><div class="line">            <span class="keyword">self</span>.fileManager = [<span class="built_in">NSFileManager</span> new];</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="comment">// 当应用终止或者进入后台时进行删除过期文件的操作。</span></div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">                                                 selector:<span class="keyword">@selector</span>(deleteOldFiles)</div><div class="line">                                                     name:<span class="built_in">UIApplicationWillTerminateNotification</span></div><div class="line">                                                   object:<span class="literal">nil</span>];</div><div class="line"></div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">                                                 selector:<span class="keyword">@selector</span>(backgroundDeleteOldFiles)</div><div class="line">                                                     name:<span class="built_in">UIApplicationDidEnterBackgroundNotification</span></div><div class="line">                                                   object:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h3 id="存储"><a href="#存储" class="headerlink" title="存储"></a>存储</h3><p><code>SDImageCache</code>会将图片同步缓存到内存，异步缓存到磁盘，主要的API如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></div><div class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 根据所给key值将图片同步缓存到内存，异步缓存到磁盘。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param image           The image to store</span></div><div class="line"><span class="comment"> * @param imageData       The image data as returned by the server, this representation will be used for disk storage</span></div><div class="line"><span class="comment"> *                        instead of converting the given image object into a storable/compressed image format in order</span></div><div class="line"><span class="comment"> *                        to save quality and CPU</span></div><div class="line"><span class="comment"> * @param key             The unique image cache key, usually it's image absolute URL</span></div><div class="line"><span class="comment"> * @param toDisk          Store the image to disk cache if YES</span></div><div class="line"><span class="comment"> * @param completionBlock A block executed after the operation is finished</span></div><div class="line"><span class="comment"> */</span></div><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</div><div class="line">         imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</div><div class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</div><div class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</div><div class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock;</div></pre></div></div></figure></p>
<p><code>SDImageCache</code>的内存缓存使用到的是一个私有类<code>SDMemoryCache</code>，该类是<code>NSCache</code>的子类，在接收到内存通知时会自行清理缓存，并且在<code>NSCache</code>的基础上添加了<code>NSMapTable</code>来支持弱引用持有图片对象。声明如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></div><div class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDMemoryCache</span> &lt;<span class="title">KeyType</span>, <span class="title">ObjectType</span>&gt; : <span class="title">NSCache</span> &lt;<span class="title">KeyType</span>, <span class="title">ObjectType</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDMemoryCache</span> &lt;<span class="title">KeyType</span>, <span class="title">ObjectType</span>&gt; ()</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nonnull</span>) <span class="built_in">NSMapTable</span>&lt;KeyType, ObjectType&gt; *weakCache; <span class="comment">// strong-weak cache</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">strong</span>, <span class="keyword">nonnull</span>) dispatch_semaphore_t weakCacheLock; <span class="comment">// a lock to keep the access to `weakCache` thread-safe</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></div></div></figure></p>
<p>因为添加了<code>NSMapTable</code>所以需要重写<code>NSCache</code>的增删方法，代码如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></div><div class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDMemoryCache</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)dealloc &#123;</div><div class="line">    [[<span class="built_in">NSNotificationCenter</span> defaultCenter] removeObserver:<span class="keyword">self</span> name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span> object:<span class="literal">nil</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="comment">// 使用strong-weak的NSMapTable存储第二份缓存。</span></div><div class="line">        <span class="comment">// 在收到内存通知NSCache进行清理时，第二份缓存将发挥作用。因为图片实例可能被其他实例持有，例如imageViews。</span></div><div class="line">        <span class="comment">// 这样的话，我们可以直接使用弱引用中还存在的对象（即因被其他实例持有还存在于内存中的对象），而不需要从磁盘中加载图片。</span></div><div class="line">        <span class="keyword">self</span>.weakCache = [[<span class="built_in">NSMapTable</span> alloc] initWithKeyOptions:<span class="built_in">NSPointerFunctionsStrongMemory</span> valueOptions:<span class="built_in">NSPointerFunctionsWeakMemory</span> capacity:<span class="number">0</span>];</div><div class="line">        <span class="keyword">self</span>.weakCacheLock = dispatch_semaphore_create(<span class="number">1</span>);</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] addObserver:<span class="keyword">self</span></div><div class="line">                                                 selector:<span class="keyword">@selector</span>(didReceiveMemoryWarning:)</div><div class="line">                                                     name:<span class="built_in">UIApplicationDidReceiveMemoryWarningNotification</span></div><div class="line">                                                   object:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)didReceiveMemoryWarning:(<span class="built_in">NSNotification</span> *)notification &#123;</div><div class="line">    [<span class="keyword">super</span> removeAllObjects];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// `setObject:forKey:` just call this with 0 cost. Override this is enough</span></div><div class="line">- (<span class="keyword">void</span>)setObject:(<span class="keyword">id</span>)obj forKey:(<span class="keyword">id</span>)key cost:(<span class="built_in">NSUInteger</span>)g &#123;</div><div class="line">    [<span class="keyword">super</span> setObject:obj forKey:key cost:g];</div><div class="line">    <span class="keyword">if</span> (key &amp;&amp; obj) &#123;</div><div class="line">        LOCK(<span class="keyword">self</span>.weakCacheLock);</div><div class="line">        [<span class="keyword">self</span>.weakCache setObject:obj forKey:key];</div><div class="line">        UNLOCK(<span class="keyword">self</span>.weakCacheLock);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">id</span>)objectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    <span class="keyword">id</span> obj = [<span class="keyword">super</span> objectForKey:key];</div><div class="line">    <span class="keyword">if</span> (key &amp;&amp; !obj) &#123;</div><div class="line">        LOCK(<span class="keyword">self</span>.weakCacheLock);</div><div class="line">        obj = [<span class="keyword">self</span>.weakCache objectForKey:key];</div><div class="line">        UNLOCK(<span class="keyword">self</span>.weakCacheLock);</div><div class="line">        <span class="keyword">if</span> (obj) &#123;</div><div class="line">            <span class="built_in">NSUInteger</span> cost = <span class="number">0</span>;</div><div class="line">            <span class="keyword">if</span> ([obj isKindOfClass:[<span class="built_in">UIImage</span> <span class="keyword">class</span>]]) &#123;</div><div class="line">                cost = SDCacheCostForImage(obj);</div><div class="line">            &#125;</div><div class="line">            [<span class="keyword">super</span> setObject:obj forKey:key cost:cost];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> obj;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeObjectForKey:(<span class="keyword">id</span>)key &#123;</div><div class="line">    [<span class="keyword">super</span> removeObjectForKey:key];</div><div class="line">    <span class="keyword">if</span> (key) &#123;</div><div class="line">        LOCK(<span class="keyword">self</span>.weakCacheLock);</div><div class="line">        [<span class="keyword">self</span>.weakCache removeObjectForKey:key];</div><div class="line">        UNLOCK(<span class="keyword">self</span>.weakCacheLock);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)removeAllObjects &#123;</div><div class="line">    [<span class="keyword">super</span> removeAllObjects];</div><div class="line">    LOCK(<span class="keyword">self</span>.weakCacheLock);</div><div class="line">    [<span class="keyword">self</span>.weakCache removeAllObjects];</div><div class="line">    UNLOCK(<span class="keyword">self</span>.weakCacheLock);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></div></div></figure></p>
<p><code>SDImageCache</code>存储图片的实现代码如下:<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">void</span>)storeImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)image</div><div class="line">         imageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData</div><div class="line">            forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key</div><div class="line">            toDisk:(<span class="built_in">BOOL</span>)toDisk</div><div class="line">        completion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock &#123;</div><div class="line">    <span class="keyword">if</span> (!image || !key) &#123;</div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            completionBlock();</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="comment">// if memory cache is enabled</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(image);</div><div class="line">        [<span class="keyword">self</span>.memCache setObject:image forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (toDisk) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">            <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">                <span class="comment">// 如果有传入图片数据就直接保存图片数据，如果没有则将图片根据是否有alpht通道将图片编码为JPEG或PNG格式。</span></div><div class="line">                <span class="built_in">NSData</span> *data = imageData;</div><div class="line">                <span class="keyword">if</span> (!data &amp;&amp; image) &#123;</div><div class="line">                    SDImageFormat format;</div><div class="line">                    <span class="keyword">if</span> (SDCGImageRefContainsAlpha(image.CGImage)) &#123;</div><div class="line">                        format = SDImageFormatPNG;</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        format = SDImageFormatJPEG;</div><div class="line">                    &#125;</div><div class="line">                    data = [[SDWebImageCodersManager sharedInstance] encodedDataWithImage:image format:format];</div><div class="line">                &#125;</div><div class="line">                [<span class="keyword">self</span> _storeImageDataToDisk:data forKey:key];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    completionBlock();</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            completionBlock();</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// Make sure to call form io queue by caller</span></div><div class="line">- (<span class="keyword">void</span>)_storeImageDataToDisk:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)imageData forKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">if</span> (!imageData || !key) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (![<span class="keyword">self</span>.fileManager fileExistsAtPath:_diskCachePath]) &#123;</div><div class="line">        [<span class="keyword">self</span>.fileManager createDirectoryAtPath:_diskCachePath withIntermediateDirectories:<span class="literal">YES</span> attributes:<span class="literal">nil</span> error:<span class="literal">NULL</span>];</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// get cache Path for image key</span></div><div class="line">    <span class="built_in">NSString</span> *cachePathForKey = [<span class="keyword">self</span> defaultCachePathForKey:key];</div><div class="line">    <span class="comment">// transform to NSUrl</span></div><div class="line">    <span class="built_in">NSURL</span> *fileURL = [<span class="built_in">NSURL</span> fileURLWithPath:cachePathForKey];</div><div class="line">    </div><div class="line">    [imageData writeToURL:fileURL options:<span class="keyword">self</span>.config.diskCacheWritingOptions error:<span class="literal">nil</span>];</div><div class="line">    </div><div class="line">    <span class="comment">// disable iCloud backup</span></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldDisableiCloud) &#123;</div><div class="line">        [fileURL setResourceValue:@YES forKey:<span class="built_in">NSURLIsExcludedFromBackupKey</span> error:<span class="literal">nil</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p><code>SDImageCache</code>会根据配置判断是否进行内存缓存、磁盘缓存或者iCloud备份。此外，在存储图片时，会将key值进行MD5之后的值作为图片文件名，代码如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cachePathForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key inPath:(<span class="keyword">nonnull</span> <span class="built_in">NSString</span> *)path &#123;</div><div class="line">    <span class="built_in">NSString</span> *filename = [<span class="keyword">self</span> cachedFileNameForKey:key];</div><div class="line">    <span class="keyword">return</span> [path stringByAppendingPathComponent:filename];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)defaultCachePathForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> cachePathForKey:key inPath:<span class="keyword">self</span>.diskCachePath];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)cachedFileNameForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">const</span> <span class="keyword">char</span> *str = key.UTF8String;</div><div class="line">    <span class="keyword">if</span> (str == <span class="literal">NULL</span>) &#123;</div><div class="line">        str = <span class="string">""</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span> r[CC_MD5_DIGEST_LENGTH];</div><div class="line">    CC_MD5(str, (CC_LONG)strlen(str), r);</div><div class="line">    <span class="built_in">NSURL</span> *keyURL = [<span class="built_in">NSURL</span> URLWithString:key];</div><div class="line">    <span class="built_in">NSString</span> *ext = keyURL ? keyURL.pathExtension : key.pathExtension;</div><div class="line">    <span class="built_in">NSString</span> *filename = [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@"%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%@"</span>,</div><div class="line">                          r[<span class="number">0</span>], r[<span class="number">1</span>], r[<span class="number">2</span>], r[<span class="number">3</span>], r[<span class="number">4</span>], r[<span class="number">5</span>], r[<span class="number">6</span>], r[<span class="number">7</span>], r[<span class="number">8</span>], r[<span class="number">9</span>], r[<span class="number">10</span>],</div><div class="line">                          r[<span class="number">11</span>], r[<span class="number">12</span>], r[<span class="number">13</span>], r[<span class="number">14</span>], r[<span class="number">15</span>], ext.length == <span class="number">0</span> ? <span class="string">@""</span> : [<span class="built_in">NSString</span> stringWithFormat:<span class="string">@".%@"</span>, ext]];</div><div class="line">    <span class="keyword">return</span> filename;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h3 id="查询"><a href="#查询" class="headerlink" title="查询"></a>查询</h3><p>查询API主要有两个，同步查询和异步查询，方法如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></div><div class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Query the cache (memory and or disk) synchronously after checking the memory cache.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param key The unique key used to store the image</span></div><div class="line"><span class="comment"> */</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Operation that queries the cache asynchronously and call the completion when done.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param key       The unique key used to store the wanted image</span></div><div class="line"><span class="comment"> * @param options   A mask to specify options to use for this cache query</span></div><div class="line"><span class="comment"> * @param doneBlock The completion block. Will not get called if the operation is cancelled</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @return a NSOperation instance containing the cache op</span></div><div class="line"><span class="comment"> */</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key options:(SDImageCacheOptions)options done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock;</div></pre></div></div></figure></p>
<p>其中，异步查询方法的options有以下选择：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></div><div class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDImageCacheOptions) &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * By default, we do not query disk data when the image is cached in memory. This mask can force to query disk data at the same time.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDImageCacheQueryDataWhenInMemory = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * By default, we query the memory cache synchronously, disk cache asynchronously. This mask can force to query disk cache synchronously.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDImageCacheQueryDiskSync = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * By default, images are decoded respecting their original size. On iOS, this flag will scale down the</span></div><div class="line"><span class="comment">     * images to a size compatible with the constrained memory of devices.</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDImageCacheScaleDownLargeImages = <span class="number">1</span> &lt;&lt; <span class="number">2</span></div><div class="line">&#125;;</div></pre></div></div></figure></p>
<p>当添加了SDImageCacheQueryDiskSync时，异步查询方法也就相当于同步查询了。它们的实现如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="comment">// 先查内存缓存，内存缓存不命中再查磁盘缓存。</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</div><div class="line">    <span class="keyword">if</span> (image) &#123;</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    image = [<span class="keyword">self</span> imageFromDiskCacheForKey:key];</div><div class="line">    <span class="keyword">return</span> image;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromMemoryCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span>.memCache objectForKey:key];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)imageFromDiskCacheForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="built_in">UIImage</span> *diskImage = [<span class="keyword">self</span> diskImageForKey:key];</div><div class="line">    <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">        <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</div><div class="line">        [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> diskImage;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)diskImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key &#123;</div><div class="line">    <span class="built_in">NSData</span> *data = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> diskImageForKey:key data:data];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)diskImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> diskImageForKey:key data:data options:<span class="number">0</span>];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)diskImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key data:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data options:(SDImageCacheOptions)options &#123;</div><div class="line">    <span class="keyword">if</span> (data) &#123;</div><div class="line">        <span class="built_in">UIImage</span> *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:data];</div><div class="line">        image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldDecompressImages) &#123;</div><div class="line">            <span class="built_in">BOOL</span> shouldScaleDown = options &amp; SDImageCacheScaleDownLargeImages;</div><div class="line">            image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;data options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> image;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSOperation</span> *)queryCacheOperationForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key options:(SDImageCacheOptions)options done:(<span class="keyword">nullable</span> SDCacheQueryCompletedBlock)doneBlock &#123;</div><div class="line">    <span class="keyword">if</span> (!key) &#123;</div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, SDImageCacheTypeNone);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// 先查内存缓存，内存缓存不命中再查磁盘缓存。</span></div><div class="line">    <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span> imageFromMemoryCacheForKey:key];</div><div class="line">    <span class="built_in">BOOL</span> shouldQueryMemoryOnly = (image &amp;&amp; !(options &amp; SDImageCacheQueryDataWhenInMemory));</div><div class="line">    <span class="keyword">if</span> (shouldQueryMemoryOnly) &#123;</div><div class="line">        <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">            doneBlock(image, <span class="literal">nil</span>, SDImageCacheTypeMemory);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="built_in">NSOperation</span> *operation = [<span class="built_in">NSOperation</span> new];</div><div class="line">    <span class="keyword">void</span>(^queryDiskBlock)(<span class="keyword">void</span>) =  ^&#123;</div><div class="line">        <span class="keyword">if</span> (operation.isCancelled) &#123;</div><div class="line">            <span class="comment">// do not call the completion if cancelled</span></div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">@autoreleasepool</span> &#123;</div><div class="line">            <span class="built_in">NSData</span> *diskData = [<span class="keyword">self</span> diskImageDataBySearchingAllPathsForKey:key];</div><div class="line">            <span class="built_in">UIImage</span> *diskImage;</div><div class="line">            SDImageCacheType cacheType = SDImageCacheTypeDisk;</div><div class="line">            <span class="keyword">if</span> (image) &#123;</div><div class="line">                diskImage = image;</div><div class="line">                cacheType = SDImageCacheTypeMemory;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (diskData) &#123;</div><div class="line">                diskImage = [<span class="keyword">self</span> diskImageForKey:key data:diskData options:options];</div><div class="line">                <span class="keyword">if</span> (diskImage &amp;&amp; <span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">                    <span class="built_in">NSUInteger</span> cost = SDCacheCostForImage(diskImage);</div><div class="line">                    [<span class="keyword">self</span>.memCache setObject:diskImage forKey:key cost:cost];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (doneBlock) &#123;</div><div class="line">                <span class="keyword">if</span> (options &amp; SDImageCacheQueryDiskSync) &#123;</div><div class="line">                    doneBlock(diskImage, diskData, cacheType);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                        doneBlock(diskImage, diskData, cacheType);</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (options &amp; SDImageCacheQueryDiskSync) &#123;</div><div class="line">        queryDiskBlock();</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, queryDiskBlock);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p>使用NSOperation是为了<code></code></p>
<h3 id="删除和清理"><a href="#删除和清理" class="headerlink" title="删除和清理"></a>删除和清理</h3><p>删除方法比较简单：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">void</span>)removeImageForKey:(<span class="keyword">nullable</span> <span class="built_in">NSString</span> *)key fromDisk:(<span class="built_in">BOOL</span>)fromDisk withCompletion:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completion &#123;</div><div class="line">    <span class="keyword">if</span> (key == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.config.shouldCacheImagesInMemory) &#123;</div><div class="line">        [<span class="keyword">self</span>.memCache removeObjectForKey:key];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (fromDisk) &#123;</div><div class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">            [<span class="keyword">self</span>.fileManager removeItemAtPath:[<span class="keyword">self</span> defaultCachePathForKey:key] error:<span class="literal">nil</span>];</div><div class="line">            </div><div class="line">            <span class="keyword">if</span> (completion) &#123;</div><div class="line">                <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                    completion();</div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (completion)&#123;</div><div class="line">        completion();</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p>在每次进入后台或者应用终止时，<code>SDImageCache</code>都会清理超过最大保存时间的文件或者在超过设置的磁盘最大使用空间时清理最旧文件。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">void</span>)backgroundDeleteOldFiles &#123;</div><div class="line">    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</div><div class="line">    <span class="keyword">if</span>(!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">UIApplication</span> *application = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">    __block <span class="built_in">UIBackgroundTaskIdentifier</span> bgTask = [application beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">        <span class="comment">// Clean up any unfinished task business by marking where you</span></div><div class="line">        <span class="comment">// stopped or ending the task outright.</span></div><div class="line">        [application endBackgroundTask:bgTask];</div><div class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="comment">// Start the long-running task and return immediately.</span></div><div class="line">    [<span class="keyword">self</span> deleteOldFilesWithCompletionBlock:^&#123;</div><div class="line">        [application endBackgroundTask:bgTask];</div><div class="line">        bgTask = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)deleteOldFilesWithCompletionBlock:(<span class="keyword">nullable</span> SDWebImageNoParamsBlock)completionBlock &#123;</div><div class="line">    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.ioQueue, ^&#123;</div><div class="line">        <span class="built_in">NSURL</span> *diskCacheURL = [<span class="built_in">NSURL</span> fileURLWithPath:<span class="keyword">self</span>.diskCachePath isDirectory:<span class="literal">YES</span>];</div><div class="line">        <span class="built_in">NSArray</span>&lt;<span class="built_in">NSString</span> *&gt; *resourceKeys = @[<span class="built_in">NSURLIsDirectoryKey</span>, <span class="built_in">NSURLContentModificationDateKey</span>, <span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line"></div><div class="line">        <span class="comment">// This enumerator prefetches useful properties for our cache files.</span></div><div class="line">        <span class="built_in">NSDirectoryEnumerator</span> *fileEnumerator = [<span class="keyword">self</span>.fileManager enumeratorAtURL:diskCacheURL</div><div class="line">                                                   includingPropertiesForKeys:resourceKeys</div><div class="line">                                                                      options:<span class="built_in">NSDirectoryEnumerationSkipsHiddenFiles</span></div><div class="line">                                                                 errorHandler:<span class="literal">NULL</span>];</div><div class="line"></div><div class="line">        <span class="built_in">NSDate</span> *expirationDate = [<span class="built_in">NSDate</span> dateWithTimeIntervalSinceNow:-<span class="keyword">self</span>.config.maxCacheAge];</div><div class="line">        <span class="built_in">NSMutableDictionary</span>&lt;<span class="built_in">NSURL</span> *, <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *&gt; *cacheFiles = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">        <span class="built_in">NSUInteger</span> currentCacheSize = <span class="number">0</span>;</div><div class="line"></div><div class="line">        <span class="comment">// Enumerate all of the files in the cache directory.  This loop has two purposes:</span></div><div class="line">        <span class="comment">//</span></div><div class="line">        <span class="comment">//  1. Removing files that are older than the expiration date.</span></div><div class="line">        <span class="comment">//  2. Storing file attributes for the size-based cleanup pass.</span></div><div class="line">        <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *urlsToDelete = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> fileEnumerator) &#123;</div><div class="line">            <span class="built_in">NSError</span> *error;</div><div class="line">            <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = [fileURL resourceValuesForKeys:resourceKeys error:&amp;error];</div><div class="line"></div><div class="line">            <span class="comment">// Skip directories and errors.</span></div><div class="line">            <span class="keyword">if</span> (error || !resourceValues || [resourceValues[<span class="built_in">NSURLIsDirectoryKey</span>] boolValue]) &#123;</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Remove files that are older than the expiration date;</span></div><div class="line">            <span class="built_in">NSDate</span> *modificationDate = resourceValues[<span class="built_in">NSURLContentModificationDateKey</span>];</div><div class="line">            <span class="keyword">if</span> ([[modificationDate laterDate:expirationDate] isEqualToDate:expirationDate]) &#123;</div><div class="line">                [urlsToDelete addObject:fileURL];</div><div class="line">                <span class="keyword">continue</span>;</div><div class="line">            &#125;</div><div class="line"></div><div class="line">            <span class="comment">// Store a reference to this file and account for its total size.</span></div><div class="line">            <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line">            currentCacheSize += totalAllocatedSize.unsignedIntegerValue;</div><div class="line">            cacheFiles[fileURL] = resourceValues;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> urlsToDelete) &#123;</div><div class="line">            [<span class="keyword">self</span>.fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// If our remaining disk cache exceeds a configured maximum size, perform a second</span></div><div class="line">        <span class="comment">// size-based cleanup pass.  We delete the oldest files first.</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.config.maxCacheSize &gt; <span class="number">0</span> &amp;&amp; currentCacheSize &gt; <span class="keyword">self</span>.config.maxCacheSize) &#123;</div><div class="line">            <span class="comment">// Target half of our maximum cache size for this cleanup pass.</span></div><div class="line">            <span class="keyword">const</span> <span class="built_in">NSUInteger</span> desiredCacheSize = <span class="keyword">self</span>.config.maxCacheSize / <span class="number">2</span>;</div><div class="line"></div><div class="line">            <span class="comment">// Sort the remaining cache files by their last modification time (oldest first).</span></div><div class="line">            <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *sortedFiles = [cacheFiles keysSortedByValueWithOptions:<span class="built_in">NSSortConcurrent</span></div><div class="line">                                                                     usingComparator:^<span class="built_in">NSComparisonResult</span>(<span class="keyword">id</span> obj1, <span class="keyword">id</span> obj2) &#123;</div><div class="line">                                                                         <span class="keyword">return</span> [obj1[<span class="built_in">NSURLContentModificationDateKey</span>] compare:obj2[<span class="built_in">NSURLContentModificationDateKey</span>]];</div><div class="line">                                                                     &#125;];</div><div class="line"></div><div class="line">            <span class="comment">// Delete files until we fall below our desired cache size.</span></div><div class="line">            <span class="keyword">for</span> (<span class="built_in">NSURL</span> *fileURL <span class="keyword">in</span> sortedFiles) &#123;</div><div class="line">                <span class="keyword">if</span> ([<span class="keyword">self</span>.fileManager removeItemAtURL:fileURL error:<span class="literal">nil</span>]) &#123;</div><div class="line">                    <span class="built_in">NSDictionary</span>&lt;<span class="built_in">NSString</span> *, <span class="keyword">id</span>&gt; *resourceValues = cacheFiles[fileURL];</div><div class="line">                    <span class="built_in">NSNumber</span> *totalAllocatedSize = resourceValues[<span class="built_in">NSURLTotalFileAllocatedSizeKey</span>];</div><div class="line">                    currentCacheSize -= totalAllocatedSize.unsignedIntegerValue;</div><div class="line"></div><div class="line">                    <span class="keyword">if</span> (currentCacheSize &lt; desiredCacheSize) &#123;</div><div class="line">                        <span class="keyword">break</span>;</div><div class="line">                    &#125;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">                completionBlock();</div><div class="line">            &#125;);</div><div class="line">        &#125;</div><div class="line">    &#125;);</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h1 id="Dwonloader"><a href="#Dwonloader" class="headerlink" title="Dwonloader"></a>Dwonloader</h1><p><code>SDWebImage</code>下载模块是使用“<code>NSOperation</code>+<code>NSURLSession</code>”来实现的。其中，<code>SDWebImageDownloaderOperation</code>实现了<code>NSOperation</code>和<code>NSURLSessionTask</code>的功能，而<code>SDWebImageDownloader</code>实现了<code>NSOperationQueue</code>和<code>NSURLSession</code>的功能。</p>
<h2 id="SDWebImageDownloaderOperation"><a href="#SDWebImageDownloaderOperation" class="headerlink" title="SDWebImageDownloaderOperation"></a>SDWebImageDownloaderOperation</h2><p><code>SDWebImageDownloaderOperation</code>继承自NSOperation，所以需要实现<code>-start</code>和<code>-cancel</code>等方法。它的多线程功能是由<code>NSURLSessionTask</code>来实现的，在start的时候提交task，在cancel的时候取消task。同时，它实现了<code>NSURLSessionTaskDelegate</code>和<code>NSURLSessionDataDelegate</code>协议，来对下载的图片数据进行处理。</p>
<h3 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h3><p>它的初始化API如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithRequest:(<span class="keyword">nullable</span> <span class="built_in">NSURLRequest</span> *)request</div><div class="line">                              inSession:(<span class="keyword">nullable</span> <span class="built_in">NSURLSession</span> *)session</div><div class="line">                                options:(SDWebImageDownloaderOptions)options <span class="built_in">NS_DESIGNATED_INITIALIZER</span>;</div></pre></div></div></figure></p>
<p>一个包含URL的request和一个用来创建task的session以及一些选项配置，可以配置的选项如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></div><div class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageDownloaderOptions) &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 将下载任务放到低优先度的queue或者task中。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageDownloaderLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 这个标志允许逐步下载，在逐步下载的过程中图片也跟着逐步展示就像浏览器那样。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageDownloaderProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 默认情况下，请求是不允许使用NSURLCache的。使用这个标志，NSURLCache将使用默认策略。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageDownloaderUseNSURLCache = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 以nil的image/imageData数据回调block，如果图片是从NSURLCache读取时（和SDWebImageDownloaderUseNSURLCache组合使用）。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageDownloaderIgnoreCachedResponse = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 在iOS4以上的版本中，当应用切换至后台时继续下载图片。这需要向系统请求额外的时间让请求在后台完成。如果后台任务(task)超时还未能成功，这个operation将被取消。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageDownloaderContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 通过将NSMutableURLRequest.HTTPShouldHandleCookies设置为YES来处理存放在NSHTTPCookieStore中的cookies。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageDownloaderHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 允许不受信任的SSL证书。在测试环境中可用，在生成环境中需谨慎使用。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageDownloaderAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 将下载任务放到高优先度的queue或者task中。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageDownloaderHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 按比例缩小大图片。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageDownloaderScaleDownLargeImages = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</div><div class="line">&#125;;</div></pre></div></div></figure></p>
<p><code>SDWebImageDownloaderOperation</code>的实现就是根据session的配置和<code>SDWebImageDownloaderOptions</code>的配置完成一次下载请求。</p>
<h3 id="开始任务"><a href="#开始任务" class="headerlink" title="开始任务"></a>开始任务</h3><p>任务的开始方法里创建了一个<code>NSURLSessionTask</code>对象并进行resume。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">void</span>)start &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isCancelled) &#123;</div><div class="line">            <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">            [<span class="keyword">self</span> reset];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 进入后台仍进行下载</span></div><div class="line">        Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</div><div class="line">        <span class="built_in">BOOL</span> hasApplication = <span class="built_in">UIApplicationClass</span> &amp;&amp; [<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">        <span class="keyword">if</span> (hasApplication &amp;&amp; [<span class="keyword">self</span> shouldContinueWhenAppEntersBackground]) &#123;</div><div class="line">            __<span class="keyword">weak</span> __typeof__ (<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</div><div class="line">            <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplicationClass</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">            <span class="keyword">self</span>.backgroundTaskId = [app beginBackgroundTaskWithExpirationHandler:^&#123;</div><div class="line">                <span class="comment">// 使用强引用是为了保证在block代码块内，对象不会被销毁</span></div><div class="line">                __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line"></div><div class="line">                <span class="keyword">if</span> (sself) &#123;</div><div class="line">                    [sself cancel];</div><div class="line"></div><div class="line">                    [app endBackgroundTask:sself.backgroundTaskId];</div><div class="line">                    sself.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;];</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="built_in">NSURLSession</span> *session = <span class="keyword">self</span>.unownedSession;</div><div class="line">        <span class="keyword">if</span> (!session) &#123;</div><div class="line">            <span class="built_in">NSURLSessionConfiguration</span> *sessionConfig = [<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration];</div><div class="line">            sessionConfig.timeoutIntervalForRequest = <span class="number">15</span>;</div><div class="line">            </div><div class="line">            session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfig</div><div class="line">                                                    delegate:<span class="keyword">self</span></div><div class="line">                                               delegateQueue:<span class="literal">nil</span>];</div><div class="line">            <span class="keyword">self</span>.ownedSession = session;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// 是否使用缓存</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderIgnoreCachedResponse) &#123;</div><div class="line">            <span class="comment">// Grab the cached data for later check</span></div><div class="line">            <span class="built_in">NSURLCache</span> *URLCache = session.configuration.URLCache;</div><div class="line">            <span class="keyword">if</span> (!URLCache) &#123;</div><div class="line">                URLCache = [<span class="built_in">NSURLCache</span> sharedURLCache];</div><div class="line">            &#125;</div><div class="line">            <span class="built_in">NSCachedURLResponse</span> *cachedResponse;</div><div class="line">            <span class="comment">// NSURLCache's `cachedResponseForRequest:` is not thread-safe, see https://developer.apple.com/documentation/foundation/nsurlcache#2317483</span></div><div class="line">            <span class="keyword">@synchronized</span> (URLCache) &#123;</div><div class="line">                cachedResponse = [URLCache cachedResponseForRequest:<span class="keyword">self</span>.request];</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">if</span> (cachedResponse) &#123;</div><div class="line">                <span class="keyword">self</span>.cachedData = cachedResponse.data;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">self</span>.dataTask = [session dataTaskWithRequest:<span class="keyword">self</span>.request];</div><div class="line">        <span class="keyword">self</span>.executing = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</div><div class="line"><span class="meta">#pragma clang diagnostic push</span></div><div class="line"><span class="meta">#pragma clang diagnostic ignored <span class="meta-string">"-Wunguarded-availability"</span></span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.dataTask respondsToSelector:<span class="keyword">@selector</span>(setPriority:)]) &#123;</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">                <span class="keyword">self</span>.dataTask.priority = <span class="built_in">NSURLSessionTaskPriorityHigh</span>;</div><div class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">                <span class="keyword">self</span>.dataTask.priority = <span class="built_in">NSURLSessionTaskPriorityLow</span>;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line"><span class="meta">#pragma clang diagnostic pop</span></div><div class="line">        [<span class="keyword">self</span>.dataTask resume];</div><div class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">            progressBlock(<span class="number">0</span>, <span class="built_in">NSURLResponseUnknownLength</span>, <span class="keyword">self</span>.request.URL);</div><div class="line">        &#125;</div><div class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStartNotification object:weakSelf];</div><div class="line">        &#125;);</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorUnknown</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Task can't be initialized"</span>&#125;]];</div><div class="line">        [<span class="keyword">self</span> done];</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    Class <span class="built_in">UIApplicationClass</span> = <span class="built_in">NSClassFromString</span>(<span class="string">@"UIApplication"</span>);</div><div class="line">    <span class="keyword">if</span>(!<span class="built_in">UIApplicationClass</span> || ![<span class="built_in">UIApplicationClass</span> respondsToSelector:<span class="keyword">@selector</span>(sharedApplication)]) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.backgroundTaskId != <span class="built_in">UIBackgroundTaskInvalid</span>) &#123;</div><div class="line">        <span class="built_in">UIApplication</span> * app = [<span class="built_in">UIApplication</span> performSelector:<span class="keyword">@selector</span>(sharedApplication)];</div><div class="line">        [app endBackgroundTask:<span class="keyword">self</span>.backgroundTaskId];</div><div class="line">        <span class="keyword">self</span>.backgroundTaskId = <span class="built_in">UIBackgroundTaskInvalid</span>;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h3 id="收到回复"><a href="#收到回复" class="headerlink" title="收到回复"></a>收到回复</h3><p>在收到response时对状态码进行校验。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session</div><div class="line">          dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask</div><div class="line">didReceiveResponse:(<span class="built_in">NSURLResponse</span> *)response</div><div class="line"> completionHandler:(<span class="keyword">void</span> (^)(<span class="built_in">NSURLSessionResponseDisposition</span> disposition))completionHandler &#123;</div><div class="line">    <span class="built_in">NSURLSessionResponseDisposition</span> disposition = <span class="built_in">NSURLSessionResponseAllow</span>;</div><div class="line">    <span class="built_in">NSInteger</span> expected = (<span class="built_in">NSInteger</span>)response.expectedContentLength;</div><div class="line">    expected = expected &gt; <span class="number">0</span> ? expected : <span class="number">0</span>;</div><div class="line">    <span class="keyword">self</span>.expectedSize = expected;</div><div class="line">    <span class="keyword">self</span>.response = response;</div><div class="line">    <span class="built_in">NSInteger</span> statusCode = [response respondsToSelector:<span class="keyword">@selector</span>(statusCode)] ? ((<span class="built_in">NSHTTPURLResponse</span> *)response).statusCode : <span class="number">200</span>;</div><div class="line">    <span class="built_in">BOOL</span> valid = statusCode &lt; <span class="number">400</span>;</div><div class="line">    <span class="comment">// 在进行请求时，会根据缓存的新鲜度判断是否直接使用缓存，当新鲜度检测到已过期时才会向服务器发起新一次请求。</span></div><div class="line">    <span class="comment">// 再次向服务器请求时有两种情况，一种是缓存再命中，服务器会返回'304 Not Modified'报文表示内容没修改，客户端可以继续使用缓存，另一种是返回200的包含数据正常报文。</span></div><div class="line">    <span class="comment">// 所以需要在返回304时，检测下本地缓存是否存在。但这不是个标准行为，我们只是加个检测。</span></div><div class="line">    <span class="keyword">if</span> (statusCode == <span class="number">304</span> &amp;&amp; !<span class="keyword">self</span>.cachedData) &#123;</div><div class="line">        valid = <span class="literal">NO</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (valid) &#123;</div><div class="line">        <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">            progressBlock(<span class="number">0</span>, expected, <span class="keyword">self</span>.request.URL);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Status code invalid and marked as cancelled. Do not call `[self.dataTask cancel]` which may mass up URLSession life cycle</span></div><div class="line">        disposition = <span class="built_in">NSURLSessionResponseCancel</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line">    <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadReceiveResponseNotification object:weakSelf];</div><div class="line">    &#125;);</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (completionHandler) &#123;</div><div class="line">        completionHandler(disposition);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h3 id="接收图片数据"><a href="#接收图片数据" class="headerlink" title="接收图片数据"></a>接收图片数据</h3><p>在接收到图片数据的过程中，根据配置是否逐步的解码这些数据生成图片，并通过相关block进行回调。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session dataTask:(<span class="built_in">NSURLSessionDataTask</span> *)dataTask didReceiveData:(<span class="built_in">NSData</span> *)data &#123;</div><div class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.imageData) &#123;</div><div class="line">        <span class="keyword">self</span>.imageData = [[<span class="built_in">NSMutableData</span> alloc] initWithCapacity:<span class="keyword">self</span>.expectedSize];</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.imageData appendData:data];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span>.options &amp; SDWebImageDownloaderProgressiveDownload) &amp;&amp; <span class="keyword">self</span>.expectedSize &gt; <span class="number">0</span>) &#123;</div><div class="line">        <span class="comment">// Get the image data</span></div><div class="line">        __block <span class="built_in">NSData</span> *imageData = [<span class="keyword">self</span>.imageData <span class="keyword">copy</span>];</div><div class="line">        <span class="comment">// Get the total bytes downloaded</span></div><div class="line">        <span class="keyword">const</span> <span class="built_in">NSInteger</span> totalSize = imageData.length;</div><div class="line">        <span class="comment">// Get the finish status</span></div><div class="line">        <span class="built_in">BOOL</span> finished = (totalSize &gt;= <span class="keyword">self</span>.expectedSize);</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.progressiveCoder) &#123;</div><div class="line">            <span class="comment">// We need to create a new instance for progressive decoding to avoid conflicts</span></div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span>&lt;SDWebImageCoder&gt;coder <span class="keyword">in</span> [SDWebImageCodersManager sharedInstance].coders) &#123;</div><div class="line">                <span class="keyword">if</span> ([coder conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageProgressiveCoder</span>)] &amp;&amp;</span></div><div class="line">                    [((<span class="keyword">id</span>&lt;SDWebImageProgressiveCoder&gt;)coder) canIncrementallyDecodeFromData:imageData]) &#123;</div><div class="line">                    <span class="keyword">self</span>.progressiveCoder = [[[coder <span class="keyword">class</span>] alloc] init];</div><div class="line">                    <span class="keyword">break</span>;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// progressive decode the image in coder queue</span></div><div class="line">        <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.coderQueue, ^&#123;</div><div class="line">            <span class="built_in">UIImage</span> *image = [<span class="keyword">self</span>.progressiveCoder incrementallyDecodedImageWithData:imageData finished:finished];</div><div class="line">            <span class="keyword">if</span> (image) &#123;</div><div class="line">                <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</div><div class="line">                image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</div><div class="line">                    image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(<span class="literal">NO</span>)&#125;];</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                <span class="comment">// We do not keep the progressive decoding image even when `finished`=YES. Because they are for view rendering but not take full function from downloader options. And some coders implementation may not keep consistent between progressive decoding and normal decoding.</span></div><div class="line">                </div><div class="line">                [<span class="keyword">self</span> callCompletionBlocksWithImage:image imageData:<span class="literal">nil</span> error:<span class="literal">nil</span> finished:<span class="literal">NO</span>];</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">for</span> (SDWebImageDownloaderProgressBlock progressBlock <span class="keyword">in</span> [<span class="keyword">self</span> callbacksForKey:kProgressCallbackKey]) &#123;</div><div class="line">        progressBlock(<span class="keyword">self</span>.imageData.length, <span class="keyword">self</span>.expectedSize, <span class="keyword">self</span>.request.URL);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h3 id="接收完图片"><a href="#接收完图片" class="headerlink" title="接收完图片"></a>接收完图片</h3><p>根据配置将图片解码后进行回调。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">void</span>)URLSession:(<span class="built_in">NSURLSession</span> *)session task:(<span class="built_in">NSURLSessionTask</span> *)task didCompleteWithError:(<span class="built_in">NSError</span> *)error &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.dataTask = <span class="literal">nil</span>;</div><div class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</div><div class="line">            <span class="keyword">if</span> (!error) &#123;</div><div class="line">                [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadFinishNotification object:weakSelf];</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// make sure to call `[self done]` to mark operation as finished</span></div><div class="line">    <span class="keyword">if</span> (error) &#123;</div><div class="line">        [<span class="keyword">self</span> callCompletionBlocksWithError:error];</div><div class="line">        [<span class="keyword">self</span> done];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span> callbacksForKey:kCompletedCallbackKey].count &gt; <span class="number">0</span>) &#123;</div><div class="line">            <span class="comment">/**</span></div><div class="line"><span class="comment">             *  If you specified to use `NSURLCache`, then the response you get here is what you need.</span></div><div class="line"><span class="comment">             */</span></div><div class="line">            __block <span class="built_in">NSData</span> *imageData = [<span class="keyword">self</span>.imageData <span class="keyword">copy</span>];</div><div class="line">            <span class="keyword">if</span> (imageData) &#123;</div><div class="line">                <span class="comment">/**  if you specified to only use cached data via `SDWebImageDownloaderIgnoreCachedResponse`,</span></div><div class="line"><span class="comment">                 *  then we should check if the cached data is equal to image data</span></div><div class="line"><span class="comment">                 */</span></div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.options &amp; SDWebImageDownloaderIgnoreCachedResponse &amp;&amp; [<span class="keyword">self</span>.cachedData isEqualToData:imageData]) &#123;</div><div class="line">                    <span class="comment">// call completion block with nil</span></div><div class="line">                    [<span class="keyword">self</span> callCompletionBlocksWithImage:<span class="literal">nil</span> imageData:<span class="literal">nil</span> error:<span class="literal">nil</span> finished:<span class="literal">YES</span>];</div><div class="line">                    [<span class="keyword">self</span> done];</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    <span class="comment">// decode the image in coder queue</span></div><div class="line">                    <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.coderQueue, ^&#123;</div><div class="line">                        <span class="built_in">UIImage</span> *image = [[SDWebImageCodersManager sharedInstance] decodedImageWithData:imageData];</div><div class="line">                        <span class="built_in">NSString</span> *key = [[SDWebImageManager sharedManager] cacheKeyForURL:<span class="keyword">self</span>.request.URL];</div><div class="line">                        image = [<span class="keyword">self</span> scaledImageForKey:key image:image];</div><div class="line">                        </div><div class="line">                        <span class="built_in">BOOL</span> shouldDecode = <span class="literal">YES</span>;</div><div class="line">                        <span class="comment">// Do not force decoding animated GIFs and WebPs</span></div><div class="line">                        <span class="keyword">if</span> (image.images) &#123;</div><div class="line">                            shouldDecode = <span class="literal">NO</span>;</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line"><span class="meta">#ifdef SD_WEBP</span></div><div class="line">                            SDImageFormat imageFormat = [<span class="built_in">NSData</span> sd_imageFormatForImageData:imageData];</div><div class="line">                            <span class="keyword">if</span> (imageFormat == SDImageFormatWebP) &#123;</div><div class="line">                                shouldDecode = <span class="literal">NO</span>;</div><div class="line">                            &#125;</div><div class="line"><span class="meta">#endif</span></div><div class="line">                        &#125;</div><div class="line">                        </div><div class="line">                        <span class="keyword">if</span> (shouldDecode) &#123;</div><div class="line">                            <span class="keyword">if</span> (<span class="keyword">self</span>.shouldDecompressImages) &#123;</div><div class="line">                                <span class="built_in">BOOL</span> shouldScaleDown = <span class="keyword">self</span>.options &amp; SDWebImageDownloaderScaleDownLargeImages;</div><div class="line">                                image = [[SDWebImageCodersManager sharedInstance] decompressedImageWithImage:image data:&amp;imageData options:@&#123;SDWebImageCoderScaleDownLargeImagesKey: @(shouldScaleDown)&#125;];</div><div class="line">                            &#125;</div><div class="line">                        &#125;</div><div class="line">                        <span class="built_in">CGSize</span> imageSize = image.size;</div><div class="line">                        <span class="keyword">if</span> (imageSize.width == <span class="number">0</span> || imageSize.height == <span class="number">0</span>) &#123;</div><div class="line">                            [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Downloaded image has 0 pixels"</span>&#125;]];</div><div class="line">                        &#125; <span class="keyword">else</span> &#123;</div><div class="line">                            [<span class="keyword">self</span> callCompletionBlocksWithImage:image imageData:imageData error:<span class="literal">nil</span> finished:<span class="literal">YES</span>];</div><div class="line">                        &#125;</div><div class="line">                        [<span class="keyword">self</span> done];</div><div class="line">                    &#125;);</div><div class="line">                &#125;</div><div class="line">            &#125; <span class="keyword">else</span> &#123;</div><div class="line">                [<span class="keyword">self</span> callCompletionBlocksWithError:[<span class="built_in">NSError</span> errorWithDomain:SDWebImageErrorDomain code:<span class="number">0</span> userInfo:@&#123;<span class="built_in">NSLocalizedDescriptionKey</span> : <span class="string">@"Image data is nil"</span>&#125;]];</div><div class="line">                [<span class="keyword">self</span> done];</div><div class="line">            &#125;</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            [<span class="keyword">self</span> done];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h3 id="取消任务"><a href="#取消任务" class="headerlink" title="取消任务"></a>取消任务</h3><p>取消任务比较简单，可以根据token来取消对应block的监听，或者直接调用cancel方法取消task的执行。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div></pre></div><div class="code"><pre><div class="line">- (<span class="built_in">BOOL</span>)cancel:(<span class="keyword">nullable</span> <span class="keyword">id</span>)token &#123;</div><div class="line">    <span class="built_in">BOOL</span> shouldCancel = <span class="literal">NO</span>;</div><div class="line">    LOCK(<span class="keyword">self</span>.callbacksLock);</div><div class="line">    [<span class="keyword">self</span>.callbackBlocks removeObjectIdenticalTo:token];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.callbackBlocks.count == <span class="number">0</span>) &#123;</div><div class="line">        shouldCancel = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line">    UNLOCK(<span class="keyword">self</span>.callbacksLock);</div><div class="line">    <span class="keyword">if</span> (shouldCancel) &#123;</div><div class="line">        [<span class="keyword">self</span> cancel];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> shouldCancel;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)cancel &#123;</div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        [<span class="keyword">self</span> cancelInternal];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)cancelInternal &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.isFinished) <span class="keyword">return</span>;</div><div class="line">    [<span class="keyword">super</span> cancel];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.dataTask) &#123;</div><div class="line">        [<span class="keyword">self</span>.dataTask cancel];</div><div class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) weakSelf = <span class="keyword">self</span>;</div><div class="line">        <span class="built_in">dispatch_async</span>(dispatch_get_main_queue(), ^&#123;</div><div class="line">            [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:SDWebImageDownloadStopNotification object:weakSelf];</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        <span class="comment">// As we cancelled the task, its callback won't be called and thus won't</span></div><div class="line">        <span class="comment">// maintain the isFinished and isExecuting flags.</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.isExecuting) <span class="keyword">self</span>.executing = <span class="literal">NO</span>;</div><div class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.isFinished) <span class="keyword">self</span>.finished = <span class="literal">YES</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    [<span class="keyword">self</span> reset];</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h2 id="SDWebImageDownloader"><a href="#SDWebImageDownloader" class="headerlink" title="SDWebImageDownloader"></a>SDWebImageDownloader</h2><p><code>SDWebImageDownloader</code>使用一个<code>NSOperationQueue</code>来进行多线程下载任务，和一个<code>NSURLSession</code>管理与服务器会话的HTTP配置，再通过创建<code>SDWebImageDownloaderOperation</code>对象来进行下载任务。它创建下载任务时不会直接返回operation而是返回一个<code>SDWebImageDownloadToken</code>对象，可以通过该对象来取消下载任务。这样的实现简化了我们的操作，在创建下载任务时就已经自动开始执行了，无需我们再手动去开启，我们只需通过block和token对象来控制图片下载的整个流程和取消操作。</p>
<h3 id="初始化-1"><a href="#初始化-1" class="headerlink" title="初始化"></a>初始化</h3><p>默认最大并行6个下载任务以及15秒请求超时。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div></pre></div><div class="code"><pre><div class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)sharedDownloader &#123;</div><div class="line">    <span class="keyword">static</span> <span class="built_in">dispatch_once_t</span> once;</div><div class="line">    <span class="keyword">static</span> <span class="keyword">id</span> instance;</div><div class="line">    <span class="built_in">dispatch_once</span>(&amp;once, ^&#123;</div><div class="line">        instance = [<span class="keyword">self</span> new];</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> instance;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> initWithSessionConfiguration:[<span class="built_in">NSURLSessionConfiguration</span> defaultSessionConfiguration]];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)initWithSessionConfiguration:(<span class="keyword">nullable</span> <span class="built_in">NSURLSessionConfiguration</span> *)sessionConfiguration &#123;</div><div class="line">    <span class="keyword">if</span> ((<span class="keyword">self</span> = [<span class="keyword">super</span> init])) &#123;</div><div class="line">        _operationClass = [SDWebImageDownloaderOperation <span class="keyword">class</span>];</div><div class="line">        _shouldDecompressImages = <span class="literal">YES</span>;</div><div class="line">        _executionOrder = SDWebImageDownloaderFIFOExecutionOrder;</div><div class="line">        _downloadQueue = [<span class="built_in">NSOperationQueue</span> new];</div><div class="line">        _downloadQueue.maxConcurrentOperationCount = <span class="number">6</span>;</div><div class="line">        _downloadQueue.name = <span class="string">@"com.hackemist.SDWebImageDownloader"</span>;</div><div class="line">        _URLOperations = [<span class="built_in">NSMutableDictionary</span> new];</div><div class="line">        _HTTPHeaders = [@&#123;<span class="string">@"Accept"</span>: <span class="string">@"image/webp,image/*;q=0.8"</span>&#125; mutableCopy];</div><div class="line">        _operationsLock = dispatch_semaphore_create(<span class="number">1</span>);</div><div class="line">        _headersLock = dispatch_semaphore_create(<span class="number">1</span>);</div><div class="line">        _downloadTimeout = <span class="number">15.0</span>;</div><div class="line"></div><div class="line">        [<span class="keyword">self</span> createNewSessionWithConfiguration:sessionConfiguration];</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)createNewSessionWithConfiguration:(<span class="built_in">NSURLSessionConfiguration</span> *)sessionConfiguration &#123;</div><div class="line">    [<span class="keyword">self</span> cancelAllDownloads];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.session) &#123;</div><div class="line">        [<span class="keyword">self</span>.session invalidateAndCancel];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    sessionConfiguration.timeoutIntervalForRequest = <span class="keyword">self</span>.downloadTimeout;</div><div class="line"></div><div class="line">    <span class="keyword">self</span>.session = [<span class="built_in">NSURLSession</span> sessionWithConfiguration:sessionConfiguration</div><div class="line">                                                 delegate:<span class="keyword">self</span></div><div class="line">                                            delegateQueue:<span class="literal">nil</span>];</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h3 id="创建下载任务"><a href="#创建下载任务" class="headerlink" title="创建下载任务"></a>创建下载任务</h3><p><code>SDWebImageDownLoader</code>是通过<code>NSDictionary</code>以URL作为key和operation作为value值来保存operation。每次创建新的下载任务时，根据URL判断是否已存在operation，如果没有再创建新的任务。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)downloadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                                   options:(SDWebImageDownloaderOptions)options</div><div class="line">                                                  progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                                 completed:(<span class="keyword">nullable</span> SDWebImageDownloaderCompletedBlock)completedBlock &#123;</div><div class="line">    __<span class="keyword">weak</span> SDWebImageDownloader *wself = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> [<span class="keyword">self</span> addProgressCallback:progressBlock completedBlock:completedBlock forURL:url createCallback:^SDWebImageDownloaderOperation *&#123;</div><div class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span> (wself) sself = wself;</div><div class="line">        <span class="built_in">NSTimeInterval</span> timeoutInterval = sself.downloadTimeout;</div><div class="line">        <span class="keyword">if</span> (timeoutInterval == <span class="number">0.0</span>) &#123;</div><div class="line">            timeoutInterval = <span class="number">15.0</span>;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="comment">// In order to prevent from potential duplicate caching (NSURLCache + SDImageCache) we disable the cache for image requests if told otherwise</span></div><div class="line">        <span class="built_in">NSURLRequestCachePolicy</span> cachePolicy = options &amp; SDWebImageDownloaderUseNSURLCache ? <span class="built_in">NSURLRequestUseProtocolCachePolicy</span> : <span class="built_in">NSURLRequestReloadIgnoringLocalCacheData</span>;</div><div class="line">        <span class="built_in">NSMutableURLRequest</span> *request = [[<span class="built_in">NSMutableURLRequest</span> alloc] initWithURL:url</div><div class="line">                                                                    cachePolicy:cachePolicy</div><div class="line">                                                                timeoutInterval:timeoutInterval];</div><div class="line">        </div><div class="line">        request.HTTPShouldHandleCookies = (options &amp; SDWebImageDownloaderHandleCookies);</div><div class="line">        request.HTTPShouldUsePipelining = <span class="literal">YES</span>;</div><div class="line">        <span class="keyword">if</span> (sself.headersFilter) &#123;</div><div class="line">            request.allHTTPHeaderFields = sself.headersFilter(url, [sself allHTTPHeaderFields]);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">else</span> &#123;</div><div class="line">            request.allHTTPHeaderFields = [sself allHTTPHeaderFields];</div><div class="line">        &#125;</div><div class="line">        SDWebImageDownloaderOperation *operation = [[sself.operationClass alloc] initWithRequest:request inSession:sself.session options:options];</div><div class="line">        operation.shouldDecompressImages = sself.shouldDecompressImages;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (sself.urlCredential) &#123;</div><div class="line">            operation.credential = sself.urlCredential;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (sself.username &amp;&amp; sself.password) &#123;</div><div class="line">            operation.credential = [<span class="built_in">NSURLCredential</span> credentialWithUser:sself.username password:sself.password persistence:<span class="built_in">NSURLCredentialPersistenceForSession</span>];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (options &amp; SDWebImageDownloaderHighPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityHigh</span>;</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (options &amp; SDWebImageDownloaderLowPriority) &#123;</div><div class="line">            operation.queuePriority = <span class="built_in">NSOperationQueuePriorityLow</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (sself.executionOrder == SDWebImageDownloaderLIFOExecutionOrder) &#123;</div><div class="line">            <span class="comment">// Emulate LIFO execution order by systematically adding new operations as last operation's dependency</span></div><div class="line">            [sself.lastAddedOperation addDependency:operation];</div><div class="line">            sself.lastAddedOperation = operation;</div><div class="line">        &#125;</div><div class="line"></div><div class="line">        <span class="keyword">return</span> operation;</div><div class="line">    &#125;];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> SDWebImageDownloadToken *)addProgressCallback:(SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                           completedBlock:(SDWebImageDownloaderCompletedBlock)completedBlock</div><div class="line">                                                   forURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                           createCallback:(SDWebImageDownloaderOperation *(^)(<span class="keyword">void</span>))createCallback &#123;</div><div class="line">    <span class="comment">// The URL will be used as the key to the callbacks dictionary so it cannot be nil. If it is nil immediately call the completed block with no image or data.</span></div><div class="line">    <span class="keyword">if</span> (url == <span class="literal">nil</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (completedBlock != <span class="literal">nil</span>) &#123;</div><div class="line">            completedBlock(<span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">nil</span>, <span class="literal">NO</span>);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">return</span> <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    LOCK(<span class="keyword">self</span>.operationsLock);</div><div class="line">    SDWebImageDownloaderOperation *operation = [<span class="keyword">self</span>.URLOperations objectForKey:url];</div><div class="line">    <span class="keyword">if</span> (!operation) &#123;</div><div class="line">        operation = createCallback();</div><div class="line">        __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</div><div class="line">        operation.completionBlock = ^&#123;</div><div class="line">            __<span class="keyword">strong</span> <span class="keyword">typeof</span>(wself) sself = wself;</div><div class="line">            <span class="keyword">if</span> (!sself) &#123;</div><div class="line">                <span class="keyword">return</span>;</div><div class="line">            &#125;</div><div class="line">            LOCK(sself.operationsLock);</div><div class="line">            [sself.URLOperations removeObjectForKey:url];</div><div class="line">            UNLOCK(sself.operationsLock);</div><div class="line">        &#125;;</div><div class="line">        [<span class="keyword">self</span>.URLOperations setObject:operation forKey:url];</div><div class="line">        <span class="comment">// Add operation to operation queue only after all configuration done according to Apple's doc.</span></div><div class="line">        <span class="comment">// `addOperation:` does not synchronously execute the `operation.completionBlock` so this will not cause deadlock.</span></div><div class="line">        [<span class="keyword">self</span>.downloadQueue addOperation:operation];</div><div class="line">    &#125;</div><div class="line">    UNLOCK(<span class="keyword">self</span>.operationsLock);</div><div class="line"></div><div class="line">    <span class="keyword">id</span> downloadOperationCancelToken = [operation addHandlersForProgress:progressBlock completed:completedBlock];</div><div class="line">    </div><div class="line">    SDWebImageDownloadToken *token = [SDWebImageDownloadToken new];</div><div class="line">    token.downloadOperation = operation;</div><div class="line">    token.url = url;</div><div class="line">    token.downloadOperationCancelToken = downloadOperationCancelToken;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> token;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h3 id="取消任务-1"><a href="#取消任务-1" class="headerlink" title="取消任务"></a>取消任务</h3><p>有两种方法可以取消任务，一种是通过创建任务时返回的<code>SDWebImageDownloadToken</code>的<code>-cancel</code>方法来取消，一种是使用<code>SDWebImageDownloader</code>的<code>-cancel:</code>或<code>-cancelAllDownloads</code>方法来取消任务。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></div><div class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDWebImageDownloadToken</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)cancel &#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.downloadOperation) &#123;</div><div class="line">        SDWebImageDownloadToken *cancelToken = <span class="keyword">self</span>.downloadOperationCancelToken;</div><div class="line">        <span class="keyword">if</span> (cancelToken) &#123;</div><div class="line">            [<span class="keyword">self</span>.downloadOperation cancel:cancelToken];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDWebImageDownloader</span></span></div><div class="line">- (<span class="keyword">void</span>)cancel:(<span class="keyword">nullable</span> SDWebImageDownloadToken *)token &#123;</div><div class="line">    <span class="built_in">NSURL</span> *url = token.url;</div><div class="line">    <span class="keyword">if</span> (!url) &#123;</div><div class="line">        <span class="keyword">return</span>;</div><div class="line">    &#125;</div><div class="line">    LOCK(<span class="keyword">self</span>.operationsLock);</div><div class="line">    SDWebImageDownloaderOperation *operation = [<span class="keyword">self</span>.URLOperations objectForKey:url];</div><div class="line">    <span class="keyword">if</span> (operation) &#123;</div><div class="line">        <span class="built_in">BOOL</span> canceled = [operation cancel:token.downloadOperationCancelToken];</div><div class="line">        <span class="keyword">if</span> (canceled) &#123;</div><div class="line">            [<span class="keyword">self</span>.URLOperations removeObjectForKey:url];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    UNLOCK(<span class="keyword">self</span>.operationsLock);</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)cancelAllDownloads &#123;</div><div class="line">    [<span class="keyword">self</span>.downloadQueue cancelAllOperations];</div><div class="line">&#125;</div><div class="line"><span class="keyword">@end</span></div></pre></div></div></figure></p>
<h1 id="Utils"><a href="#Utils" class="headerlink" title="Utils"></a>Utils</h1><h2 id="SDWebImageManager"><a href="#SDWebImageManager" class="headerlink" title="SDWebImageManager"></a>SDWebImageManager</h2><p>该类主要集成了Downloader和Cache两模块的功能。根据URL加载一张图片的正常流程是，先从缓存中尝试获取该图片，如果图片不存在缓存中，再去向服务器请求下载，<code>SDWebImageManager</code>就实现了以上流程。该类最重要的API就是一个加载图片的方法，如下:<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></div><div class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * 当图片存在缓存时使用缓存的图片，否则根据所给URL下载图片。</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param url            图片URL。</span></div><div class="line"><span class="comment"> * @param options        关于加载图片的一些选项。</span></div><div class="line"><span class="comment"> * @param progressBlock  下载图片过程中回调的block。</span></div><div class="line"><span class="comment"> *                       @note 该block在后台进程执行。</span></div><div class="line"><span class="comment"> * @param completedBlock 当operation任务完成时回调的block。</span></div><div class="line"><span class="comment"> */</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                              options:(SDWebImageOptions)options</div><div class="line">                                             progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                            completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock;</div></pre></div></div></figure></p>
<p>关于这个加载选项参数，有以下的可选项：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div></pre></div><div class="code"><pre><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_OPTIONS</span>(<span class="built_in">NSUInteger</span>, SDWebImageOptions) &#123;</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 默认情况下，当一个URL下载失败时，会把其加入黑名单中，所以不会对该URL进行重试。</span></div><div class="line"><span class="comment">     * 该选项取消黑名单。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageRetryFailed = <span class="number">1</span> &lt;&lt; <span class="number">0</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 默认情况下，图片在UI交互过程中也会进行下载，该选项禁止这种特性，以此来防止滚动UIScrollView时出现卡顿。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageLowPriority = <span class="number">1</span> &lt;&lt; <span class="number">1</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 这个选项禁止使用磁盘缓存。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageCacheMemoryOnly = <span class="number">1</span> &lt;&lt; <span class="number">2</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 该选择支持图片进行逐渐解码。默认情况下是当图片完整下载完成后再进行回调。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageProgressiveDownload = <span class="number">1</span> &lt;&lt; <span class="number">3</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 当图片在本地缓存中时，还是要根据URL缓存的新鲜度检测来判断是否使用图片缓存，当需要时将根据服务器信息刷新图片。</span></div><div class="line"><span class="comment">     * 将由NSURLCache代替SDWebImage来处理缓存，这可能会有轻微的性能损耗。</span></div><div class="line"><span class="comment">     * 这选项能有效处理相同URL返回不同图片数据的情况, 例如 Facebook graph api profile pics.</span></div><div class="line"><span class="comment">     * 当图片有更新时，将回调使用旧的缓存图片和最终图片回调completionBlock两次。</span></div><div class="line"><span class="comment">     *</span></div><div class="line"><span class="comment">     * 使用这个选项当你不能确定使用的URL是静态的。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageRefreshCached = <span class="number">1</span> &lt;&lt; <span class="number">4</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 在iOS4以上系统中，允许在应用进入后台后继续下载图片。通过向系统请求获取后台允许的额外时间来完成请求。 </span></div><div class="line"><span class="comment">     * 如果后台任务超时还未能完成，这个operation将取消。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageContinueInBackground = <span class="number">1</span> &lt;&lt; <span class="number">5</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否使用Cookie。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageHandleCookies = <span class="number">1</span> &lt;&lt; <span class="number">6</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 允许不受信任的SSL证书。</span></div><div class="line"><span class="comment">     * 可以在测试时使用。生产环境中慎用。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageAllowInvalidSSLCertificates = <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 默认情况下，图片在当前队列中被加载。这个选项使得图片优先加载。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageHighPriority = <span class="number">1</span> &lt;&lt; <span class="number">8</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 不使用占位图片。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageDelayPlaceholder = <span class="number">1</span> &lt;&lt; <span class="number">9</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 我们在动态图片中通常不调用transformDownloadedImage代理方法，因为大多数transform方法会损坏图片。</span></div><div class="line"><span class="comment">     * 该选项设置在任何情况下都能对图片进行转换。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageTransformAnimatedImage = <span class="number">1</span> &lt;&lt; <span class="number">10</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 默认情况下，图片在下载完成后会被添加。但是在某些情况下，我们希望在设置图片先进行一些处理（进行过滤或者对图片进行淡入淡出处理）</span></div><div class="line"><span class="comment">     * 如果你希望在成功加载图片后手动设置图片，可以使用改选项。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageAvoidAutoSetImage = <span class="number">1</span> &lt;&lt; <span class="number">11</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否裁剪超大图片。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageScaleDownLargeImages = <span class="number">1</span> &lt;&lt; <span class="number">12</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否在内存缓存命中后继续查找磁盘缓存。</span></div><div class="line"><span class="comment">     * 使用这个选项时最好也添加`SDWebImageQueryDiskSync`选项，来保证图片在同一轮runloop中被加载。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageQueryDataWhenInMemory = <span class="number">1</span> &lt;&lt; <span class="number">13</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 是否同步进行磁盘缓存查询。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageQueryDiskSync = <span class="number">1</span> &lt;&lt; <span class="number">14</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 只使用缓存加载图片，当缓存未命中也不进行网络请求。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageFromCacheOnly = <span class="number">1</span> &lt;&lt; <span class="number">15</span>,</div><div class="line">    <span class="comment">/**</span></div><div class="line"><span class="comment">     * 默认情况下，只有当图片时通过网络下载的才会调用视图的过度(transition)方法。</span></div><div class="line"><span class="comment">     * 该选项强制当图片从内存缓存或者磁盘缓存中加载时也执行过度方法。</span></div><div class="line"><span class="comment">     */</span></div><div class="line">    SDWebImageForceTransition = <span class="number">1</span> &lt;&lt; <span class="number">16</span></div><div class="line">&#125;;</div></pre></div></div></figure></p>
<p>加载方法主要分两步，第一步尝试通过<code>SDImageCache</code>从缓存中读取图片数据，第二步图片不存在缓存中，则使用<code>SDWebImageDownloader</code>进行下载。<br><strong>从缓存中加载</strong><br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">id</span> &lt;SDWebImageOperation&gt;)loadImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                                     options:(SDWebImageOptions)options</div><div class="line">                                    progress:(<span class="keyword">nullable</span> SDWebImageDownloaderProgressBlock)progressBlock</div><div class="line">                                   completed:(<span class="keyword">nullable</span> SDInternalCompletionBlock)completedBlock &#123;</div><div class="line">    <span class="comment">// Invoking this method without a completedBlock is pointless</span></div><div class="line">    <span class="built_in">NSAssert</span>(completedBlock != <span class="literal">nil</span>, <span class="string">@"If you mean to prefetch the image, use -[SDWebImagePrefetcher prefetchURLs] instead"</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Very common mistake is to send the URL using NSString object instead of NSURL. For some strange reason, Xcode won't</span></div><div class="line">    <span class="comment">// throw any warning for this type mismatch. Here we failsafe this error by allowing URLs to be passed as NSString.</span></div><div class="line">    <span class="keyword">if</span> ([url isKindOfClass:<span class="built_in">NSString</span>.class]) &#123;</div><div class="line">        url = [<span class="built_in">NSURL</span> URLWithString:(<span class="built_in">NSString</span> *)url];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="comment">// Prevents app crashing on argument type error like sending NSNull instead of NSURL</span></div><div class="line">    <span class="keyword">if</span> (![url isKindOfClass:<span class="built_in">NSURL</span>.class]) &#123;</div><div class="line">        url = <span class="literal">nil</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    SDWebImageCombinedOperation *operation = [SDWebImageCombinedOperation new];</div><div class="line">    operation.manager = <span class="keyword">self</span>;</div><div class="line"></div><div class="line">    <span class="built_in">BOOL</span> isFailedUrl = <span class="literal">NO</span>;</div><div class="line">    <span class="keyword">if</span> (url) &#123;</div><div class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">            isFailedUrl = [<span class="keyword">self</span>.failedURLs containsObject:url];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (url.absoluteString.length == <span class="number">0</span> || (!(options &amp; SDWebImageRetryFailed) &amp;&amp; isFailedUrl)) &#123;</div><div class="line">        [<span class="keyword">self</span> callCompletionBlockForOperation:operation completion:completedBlock error:[<span class="built_in">NSError</span> errorWithDomain:<span class="built_in">NSURLErrorDomain</span> code:<span class="built_in">NSURLErrorFileDoesNotExist</span> userInfo:<span class="literal">nil</span>] url:url];</div><div class="line">        <span class="keyword">return</span> operation;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.runningOperations) &#123;</div><div class="line">        [<span class="keyword">self</span>.runningOperations addObject:operation];</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">NSString</span> *key = [<span class="keyword">self</span> cacheKeyForURL:url];</div><div class="line">    </div><div class="line">    SDImageCacheOptions cacheOptions = <span class="number">0</span>;</div><div class="line">    <span class="keyword">if</span> (options &amp; SDWebImageQueryDataWhenInMemory) cacheOptions |= SDImageCacheQueryDataWhenInMemory;</div><div class="line">    <span class="keyword">if</span> (options &amp; SDWebImageQueryDiskSync) cacheOptions |= SDImageCacheQueryDiskSync;</div><div class="line">    <span class="keyword">if</span> (options &amp; SDWebImageScaleDownLargeImages) cacheOptions |= SDImageCacheScaleDownLargeImages;</div><div class="line">    </div><div class="line">    __<span class="keyword">weak</span> SDWebImageCombinedOperation *weakOperation = operation;</div><div class="line">    operation.cacheOperation = [<span class="keyword">self</span>.imageCache queryCacheOperationForKey:key options:cacheOptions done:^(<span class="built_in">UIImage</span> *cachedImage, <span class="built_in">NSData</span> *cachedData, SDImageCacheType cacheType) &#123;</div><div class="line">        __<span class="keyword">strong</span> __<span class="keyword">typeof</span>(weakOperation) strongOperation = weakOperation;</div><div class="line">        <span class="keyword">if</span> (!strongOperation || strongOperation.isCancelled) &#123;</div><div class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">            <span class="keyword">return</span>;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="comment">// Check whether we should download image from network</span></div><div class="line">        <span class="built_in">BOOL</span> shouldDownload = (!(options &amp; SDWebImageFromCacheOnly))</div><div class="line">            &amp;&amp; (!cachedImage || options &amp; SDWebImageRefreshCached)</div><div class="line">            &amp;&amp; (![<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldDownloadImageForURL:)] || [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldDownloadImageForURL:url]);</div><div class="line">        <span class="keyword">if</span> (shouldDownload) &#123;</div><div class="line">       	<span class="comment">//第二步内容，通过网络下载图片</span></div><div class="line">       	...</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cachedImage) &#123;</div><div class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="literal">YES</span> url:url];</div><div class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="comment">// Image not in cache and download disallowed by delegate</span></div><div class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:<span class="literal">nil</span> data:<span class="literal">nil</span> error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:<span class="literal">YES</span> url:url];</div><div class="line">            [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongOperation];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line"></div><div class="line">    <span class="keyword">return</span> operation;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p>其中<code>SDWebImageCombinedOperation</code>是一个结合缓存operation和下载operation的类，该类实现了<code>SDWebImageOperation</code>协议提供了取消方法<code>-cancel</code>，所以当需要取消不管是缓存还是下载operation时，只需调用该类的<code>-cancel</code>方法即可。它的实现如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></div><div class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageCombinedOperation</span> : <span class="title">NSObject</span> &lt;<span class="title">SDWebImageOperation</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">assign</span>, <span class="keyword">nonatomic</span>, <span class="keyword">getter</span> = isCancelled) <span class="built_in">BOOL</span> cancelled;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDWebImageDownloadToken *downloadToken;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">strong</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) <span class="built_in">NSOperation</span> *cacheOperation;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">weak</span>, <span class="keyword">nonatomic</span>, <span class="keyword">nullable</span>) SDWebImageManager *manager;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDWebImageCombinedOperation</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)cancel &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.cancelled = <span class="literal">YES</span>;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.cacheOperation) &#123;</div><div class="line">            [<span class="keyword">self</span>.cacheOperation cancel];</div><div class="line">            <span class="keyword">self</span>.cacheOperation = <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.downloadToken) &#123;</div><div class="line">            [<span class="keyword">self</span>.manager.imageDownloader cancel:<span class="keyword">self</span>.downloadToken];</div><div class="line">        &#125;</div><div class="line">        [<span class="keyword">self</span>.manager safelyRemoveOperationFromRunning:<span class="keyword">self</span>];</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></div></div></figure></p>
<p><strong>通过网络下载图片</strong><br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div></pre></div><div class="code"><pre><div class="line"><span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">    <span class="comment">// If image was found in the cache but SDWebImageRefreshCached is provided, notify about the cached image</span></div><div class="line">    <span class="comment">// AND try to re-download it in order to let a chance to NSURLCache to refresh it from server.</span></div><div class="line">    [<span class="keyword">self</span> callCompletionBlockForOperation:strongOperation completion:completedBlock image:cachedImage data:cachedData error:<span class="literal">nil</span> cacheType:cacheType finished:<span class="literal">YES</span> url:url];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// download if no image or requested to refresh anyway, and download allowed by delegate</span></div><div class="line">SDWebImageDownloaderOptions downloaderOptions = <span class="number">0</span>;</div><div class="line"><span class="keyword">if</span> (options &amp; SDWebImageLowPriority) downloaderOptions |= SDWebImageDownloaderLowPriority;</div><div class="line"><span class="keyword">if</span> (options &amp; SDWebImageProgressiveDownload) downloaderOptions |= SDWebImageDownloaderProgressiveDownload;</div><div class="line"><span class="keyword">if</span> (options &amp; SDWebImageRefreshCached) downloaderOptions |= SDWebImageDownloaderUseNSURLCache;</div><div class="line"><span class="keyword">if</span> (options &amp; SDWebImageContinueInBackground) downloaderOptions |= SDWebImageDownloaderContinueInBackground;</div><div class="line"><span class="keyword">if</span> (options &amp; SDWebImageHandleCookies) downloaderOptions |= SDWebImageDownloaderHandleCookies;</div><div class="line"><span class="keyword">if</span> (options &amp; SDWebImageAllowInvalidSSLCertificates) downloaderOptions |= SDWebImageDownloaderAllowInvalidSSLCertificates;</div><div class="line"><span class="keyword">if</span> (options &amp; SDWebImageHighPriority) downloaderOptions |= SDWebImageDownloaderHighPriority;</div><div class="line"><span class="keyword">if</span> (options &amp; SDWebImageScaleDownLargeImages) downloaderOptions |= SDWebImageDownloaderScaleDownLargeImages;</div><div class="line"></div><div class="line"><span class="keyword">if</span> (cachedImage &amp;&amp; options &amp; SDWebImageRefreshCached) &#123;</div><div class="line">    <span class="comment">// force progressive off if image already cached but forced refreshing</span></div><div class="line">    downloaderOptions &amp;= ~SDWebImageDownloaderProgressiveDownload;</div><div class="line">    <span class="comment">// ignore image read from NSURLCache if image if cached but force refreshing</span></div><div class="line">    downloaderOptions |= SDWebImageDownloaderIgnoreCachedResponse;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// `SDWebImageCombinedOperation` -&gt; `SDWebImageDownloadToken` -&gt; `downloadOperationCancelToken`, which is a `SDCallbacksDictionary` and retain the completed block below, so we need weak-strong again to avoid retain cycle</span></div><div class="line">__<span class="keyword">weak</span> <span class="keyword">typeof</span>(strongOperation) weakSubOperation = strongOperation;</div><div class="line">strongOperation.downloadToken = [<span class="keyword">self</span>.imageDownloader downloadImageWithURL:url options:downloaderOptions progress:progressBlock completed:^(<span class="built_in">UIImage</span> *downloadedImage, <span class="built_in">NSData</span> *downloadedData, <span class="built_in">NSError</span> *error, <span class="built_in">BOOL</span> finished) &#123;</div><div class="line">    __<span class="keyword">strong</span> <span class="keyword">typeof</span>(weakSubOperation) strongSubOperation = weakSubOperation;</div><div class="line">    <span class="keyword">if</span> (!strongSubOperation || strongSubOperation.isCancelled) &#123;</div><div class="line">        <span class="comment">// Do nothing if the operation was cancelled</span></div><div class="line">        <span class="comment">// See #699 for more details</span></div><div class="line">        <span class="comment">// if we would call the completedBlock, there could be a race condition between this block and another completedBlock for the same object, so if this one is called second, we will overwrite the new data</span></div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (error) &#123;</div><div class="line">        [<span class="keyword">self</span> callCompletionBlockForOperation:strongSubOperation completion:completedBlock error:error url:url];</div><div class="line">        <span class="built_in">BOOL</span> shouldBlockFailedURL;</div><div class="line">        <span class="comment">// Check whether we should block failed url</span></div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:shouldBlockFailedURL:withError:)]) &#123;</div><div class="line">            shouldBlockFailedURL = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> shouldBlockFailedURL:url withError:error];</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            shouldBlockFailedURL = (   error.code != <span class="built_in">NSURLErrorNotConnectedToInternet</span></div><div class="line">                                    &amp;&amp; error.code != <span class="built_in">NSURLErrorCancelled</span></div><div class="line">                                    &amp;&amp; error.code != <span class="built_in">NSURLErrorTimedOut</span></div><div class="line">                                    &amp;&amp; error.code != <span class="built_in">NSURLErrorInternationalRoamingOff</span></div><div class="line">                                    &amp;&amp; error.code != <span class="built_in">NSURLErrorDataNotAllowed</span></div><div class="line">                                    &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotFindHost</span></div><div class="line">                                    &amp;&amp; error.code != <span class="built_in">NSURLErrorCannotConnectToHost</span></div><div class="line">                                    &amp;&amp; error.code != <span class="built_in">NSURLErrorNetworkConnectionLost</span>);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (shouldBlockFailedURL) &#123;</div><div class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                [<span class="keyword">self</span>.failedURLs addObject:url];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">if</span> ((options &amp; SDWebImageRetryFailed)) &#123;</div><div class="line">            <span class="keyword">@synchronized</span> (<span class="keyword">self</span>.failedURLs) &#123;</div><div class="line">                [<span class="keyword">self</span>.failedURLs removeObject:url];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="built_in">BOOL</span> cacheOnDisk = !(options &amp; SDWebImageCacheMemoryOnly);</div><div class="line">        </div><div class="line">        <span class="comment">// We've done the scale process in SDWebImageDownloader with the shared manager, this is used for custom manager and avoid extra scale.</span></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span> != [SDWebImageManager sharedManager] &amp;&amp; <span class="keyword">self</span>.cacheKeyFilter &amp;&amp; downloadedImage) &#123;</div><div class="line">            downloadedImage = [<span class="keyword">self</span> scaledImageForKey:key image:downloadedImage];</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        <span class="keyword">if</span> (options &amp; SDWebImageRefreshCached &amp;&amp; cachedImage &amp;&amp; !downloadedImage) &#123;</div><div class="line">            <span class="comment">// Image refresh hit the NSURLCache cache, do not call the completion block</span></div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (downloadedImage &amp;&amp; (!downloadedImage.images || (options &amp; SDWebImageTransformAnimatedImage)) &amp;&amp; [<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imageManager:transformDownloadedImage:withURL:)]) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">                <span class="built_in">UIImage</span> *transformedImage = [<span class="keyword">self</span>.delegate imageManager:<span class="keyword">self</span> transformDownloadedImage:downloadedImage withURL:url];</div><div class="line">                </div><div class="line">                <span class="keyword">if</span> (transformedImage &amp;&amp; finished) &#123;</div><div class="line">                    <span class="built_in">BOOL</span> imageWasTransformed = ![transformedImage isEqual:downloadedImage];</div><div class="line">                    <span class="built_in">NSData</span> *cacheData;</div><div class="line">                    <span class="comment">// pass nil if the image was transformed, so we can recalculate the data from the image</span></div><div class="line">                    <span class="keyword">if</span> (<span class="keyword">self</span>.cacheSerializer) &#123;</div><div class="line">                        cacheData = <span class="keyword">self</span>.cacheSerializer(transformedImage, (imageWasTransformed ? <span class="literal">nil</span> : downloadedData), url);</div><div class="line">                    &#125; <span class="keyword">else</span> &#123;</div><div class="line">                        cacheData = (imageWasTransformed ? <span class="literal">nil</span> : downloadedData);</div><div class="line">                    &#125;</div><div class="line">                    [<span class="keyword">self</span>.imageCache storeImage:transformedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                &#125;</div><div class="line">                </div><div class="line">                [<span class="keyword">self</span> callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:transformedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> &#123;</div><div class="line">            <span class="keyword">if</span> (downloadedImage &amp;&amp; finished) &#123;</div><div class="line">                <span class="keyword">if</span> (<span class="keyword">self</span>.cacheSerializer) &#123;</div><div class="line">                    <span class="built_in">dispatch_async</span>(dispatch_get_global_queue(DISPATCH_QUEUE_PRIORITY_HIGH, <span class="number">0</span>), ^&#123;</div><div class="line">                        <span class="built_in">NSData</span> *cacheData = <span class="keyword">self</span>.cacheSerializer(downloadedImage, downloadedData, url);</div><div class="line">                        [<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:cacheData forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                    &#125;);</div><div class="line">                &#125; <span class="keyword">else</span> &#123;</div><div class="line">                    [<span class="keyword">self</span>.imageCache storeImage:downloadedImage imageData:downloadedData forKey:key toDisk:cacheOnDisk completion:<span class="literal">nil</span>];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            [<span class="keyword">self</span> callCompletionBlockForOperation:strongSubOperation completion:completedBlock image:downloadedImage data:downloadedData error:<span class="literal">nil</span> cacheType:SDImageCacheTypeNone finished:finished url:url];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="keyword">if</span> (finished) &#123;</div><div class="line">        [<span class="keyword">self</span> safelyRemoveOperationFromRunning:strongSubOperation];</div><div class="line">    &#125;</div><div class="line">&#125;];</div></pre></div></div></figure></p>
<h2 id="SDWebImagePrefetcher"><a href="#SDWebImagePrefetcher" class="headerlink" title="SDWebImagePrefetcher"></a>SDWebImagePrefetcher</h2><p><code>SDWebImagePrefetcher</code>用于图片的预加载，通过<code>SDWebImageManager</code>的加载图片方法对图片进行加载，然后通过代理的方式进行回调。它的代理协议如下:<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></div><div class="code"><pre><div class="line"><span class="class"><span class="keyword">@protocol</span> <span class="title">SDWebImagePrefetcherDelegate</span> &lt;<span class="title">NSObject</span>&gt;</span></div><div class="line"></div><div class="line"><span class="keyword">@optional</span></div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Called when an image was prefetched.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param imagePrefetcher The current image prefetcher</span></div><div class="line"><span class="comment"> * @param imageURL        The image url that was prefetched</span></div><div class="line"><span class="comment"> * @param finishedCount   The total number of images that were prefetched (successful or not)</span></div><div class="line"><span class="comment"> * @param totalCount      The total number of images that were to be prefetched</span></div><div class="line"><span class="comment"> */</span></div><div class="line">- (<span class="keyword">void</span>)imagePrefetcher:(<span class="keyword">nonnull</span> SDWebImagePrefetcher *)imagePrefetcher didPrefetchURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)imageURL finishedCount:(<span class="built_in">NSUInteger</span>)finishedCount totalCount:(<span class="built_in">NSUInteger</span>)totalCount;</div><div class="line"></div><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Called when all images are prefetched.</span></div><div class="line"><span class="comment"> * @param imagePrefetcher The current image prefetcher</span></div><div class="line"><span class="comment"> * @param totalCount      The total number of images that were prefetched (whether successful or not)</span></div><div class="line"><span class="comment"> * @param skippedCount    The total number of images that were skipped</span></div><div class="line"><span class="comment"> */</span></div><div class="line">- (<span class="keyword">void</span>)imagePrefetcher:(<span class="keyword">nonnull</span> SDWebImagePrefetcher *)imagePrefetcher didFinishWithTotalCount:(<span class="built_in">NSUInteger</span>)totalCount skippedCount:(<span class="built_in">NSUInteger</span>)skippedCount;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></div></div></figure></p>
<p>预加载的主要方法如下:<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></div><div class="code"><pre><div class="line"><span class="comment">/**</span></div><div class="line"><span class="comment"> * Assign list of URLs to let SDWebImagePrefetcher to queue the prefetching,</span></div><div class="line"><span class="comment"> * currently one image is downloaded at a time,</span></div><div class="line"><span class="comment"> * and skips images for failed downloads and proceed to the next image in the list.</span></div><div class="line"><span class="comment"> * Any previously-running prefetch operations are canceled.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * @param urls            list of URLs to prefetch</span></div><div class="line"><span class="comment"> * @param progressBlock   block to be called when progress updates; </span></div><div class="line"><span class="comment"> *                        first parameter is the number of completed (successful or not) requests, </span></div><div class="line"><span class="comment"> *                        second parameter is the total number of images originally requested to be prefetched</span></div><div class="line"><span class="comment"> * @param completionBlock block to be called when prefetching is completed</span></div><div class="line"><span class="comment"> *                        first param is the number of completed (successful or not) requests,</span></div><div class="line"><span class="comment"> *                        second parameter is the number of skipped requests</span></div><div class="line"><span class="comment"> */</span></div><div class="line">- (<span class="keyword">void</span>)prefetchURLs:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *)urls</div><div class="line">            progress:(<span class="keyword">nullable</span> SDWebImagePrefetcherProgressBlock)progressBlock</div><div class="line">           completed:(<span class="keyword">nullable</span> SDWebImagePrefetcherCompletionBlock)completionBlock;</div></pre></div></div></figure></p>
<p>实现如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">void</span>)prefetchURLs:(<span class="keyword">nullable</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *)urls</div><div class="line">            progress:(<span class="keyword">nullable</span> SDWebImagePrefetcherProgressBlock)progressBlock</div><div class="line">           completed:(<span class="keyword">nullable</span> SDWebImagePrefetcherCompletionBlock)completionBlock &#123;</div><div class="line">    [<span class="keyword">self</span> cancelPrefetching]; <span class="comment">// Prevent duplicate prefetch request</span></div><div class="line">    <span class="keyword">self</span>.startedTime = <span class="built_in">CFAbsoluteTimeGetCurrent</span>();</div><div class="line">    <span class="keyword">self</span>.prefetchURLs = urls;</div><div class="line">    <span class="keyword">self</span>.completionBlock = completionBlock;</div><div class="line">    <span class="keyword">self</span>.progressBlock = progressBlock;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (urls.count == <span class="number">0</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (completionBlock) &#123;</div><div class="line">            completionBlock(<span class="number">0</span>,<span class="number">0</span>);</div><div class="line">        &#125;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="comment">// Starts prefetching from the very first image on the list with the max allowed concurrency</span></div><div class="line">        <span class="built_in">NSUInteger</span> listCount = <span class="keyword">self</span>.prefetchURLs.count;</div><div class="line">        <span class="keyword">for</span> (<span class="built_in">NSUInteger</span> i = <span class="number">0</span>; i &lt; <span class="keyword">self</span>.maxConcurrentDownloads &amp;&amp; <span class="keyword">self</span>.requestedCount &lt; listCount; i++) &#123;</div><div class="line">            [<span class="keyword">self</span> startPrefetchingAtIndex:i];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)startPrefetchingAtIndex:(<span class="built_in">NSUInteger</span>)index &#123;</div><div class="line">    <span class="built_in">NSURL</span> *currentURL;</div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">if</span> (index &gt;= <span class="keyword">self</span>.prefetchURLs.count) <span class="keyword">return</span>;</div><div class="line">        currentURL = <span class="keyword">self</span>.prefetchURLs[index];</div><div class="line">        <span class="keyword">self</span>.requestedCount++;</div><div class="line">    &#125;</div><div class="line">    [<span class="keyword">self</span>.manager loadImageWithURL:currentURL options:<span class="keyword">self</span>.options progress:<span class="literal">nil</span> completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">        <span class="keyword">if</span> (!finished) <span class="keyword">return</span>;</div><div class="line">        <span class="keyword">self</span>.finishedCount++;</div><div class="line"></div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.progressBlock) &#123;</div><div class="line">            <span class="keyword">self</span>.progressBlock(<span class="keyword">self</span>.finishedCount,(<span class="keyword">self</span>.prefetchURLs).count);</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (!image) &#123;</div><div class="line">            <span class="comment">// Add last failed</span></div><div class="line">            <span class="keyword">self</span>.skippedCount++;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> ([<span class="keyword">self</span>.delegate respondsToSelector:<span class="keyword">@selector</span>(imagePrefetcher:didPrefetchURL:finishedCount:totalCount:)]) &#123;</div><div class="line">            [<span class="keyword">self</span>.delegate imagePrefetcher:<span class="keyword">self</span></div><div class="line">                            didPrefetchURL:currentURL</div><div class="line">                             finishedCount:<span class="keyword">self</span>.finishedCount</div><div class="line">                                totalCount:<span class="keyword">self</span>.prefetchURLs.count</div><div class="line">             ];</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.prefetchURLs.count &gt; <span class="keyword">self</span>.requestedCount) &#123;</div><div class="line">            <span class="built_in">dispatch_async</span>(<span class="keyword">self</span>.prefetcherQueue, ^&#123;</div><div class="line">                <span class="comment">// we need dispatch to avoid function recursion call. This can prevent stack overflow even for huge urls list</span></div><div class="line">                [<span class="keyword">self</span> startPrefetchingAtIndex:<span class="keyword">self</span>.requestedCount];</div><div class="line">            &#125;);</div><div class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">self</span>.finishedCount == <span class="keyword">self</span>.requestedCount) &#123;</div><div class="line">            [<span class="keyword">self</span> reportStatus];</div><div class="line">            <span class="keyword">if</span> (<span class="keyword">self</span>.completionBlock) &#123;</div><div class="line">                <span class="keyword">self</span>.completionBlock(<span class="keyword">self</span>.finishedCount, <span class="keyword">self</span>.skippedCount);</div><div class="line">                <span class="keyword">self</span>.completionBlock = <span class="literal">nil</span>;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">self</span>.progressBlock = <span class="literal">nil</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h2 id="SDWebImageTransition"><a href="#SDWebImageTransition" class="headerlink" title="SDWebImageTransition"></a>SDWebImageTransition</h2><p>这个类定义了图片过度的方式，减少了使用过度动画的代码。共定义了以下7种过度方式：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></div><div class="code"><pre><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">SDWebImageTransition</span> (<span class="title">Conveniences</span>)</span></div><div class="line"></div><div class="line"><span class="comment">// class property is available in Xcode 8. We will drop the Xcode 7.3 support in 5.x</span></div><div class="line"><span class="meta">#if __has_feature(objc_class_property)</span></div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *fadeTransition;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *flipFromLeftTransition;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *flipFromRightTransition;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *flipFromTopTransition;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *flipFromBottomTransition;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *curlUpTransition;</div><div class="line"><span class="keyword">@property</span> (<span class="keyword">nonatomic</span>, <span class="keyword">class</span>, <span class="keyword">nonnull</span>, <span class="keyword">readonly</span>) SDWebImageTransition *curlDownTransition;</div><div class="line"><span class="meta">#else</span></div><div class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)fadeTransition;</div><div class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)flipFromLeftTransition;</div><div class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)flipFromRightTransition;</div><div class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)flipFromTopTransition;</div><div class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)flipFromBottomTransition;</div><div class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)curlUpTransition;</div><div class="line">+ (<span class="keyword">nonnull</span> <span class="keyword">instancetype</span>)curlDownTransition;</div><div class="line"><span class="meta">#endif</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></div></div></figure></p>
<p>实现方面也很简单，默认动画持续时间设置为0.5秒，不同动画设置不同的<code>UIViewAnimationOptions</code>：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></div><div class="code"><pre><div class="line"><span class="class"><span class="keyword">@implementation</span> <span class="title">SDWebImageTransition</span></span></div><div class="line"></div><div class="line">- (<span class="keyword">instancetype</span>)init &#123;</div><div class="line">    <span class="keyword">self</span> = [<span class="keyword">super</span> init];</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="keyword">self</span>.duration = <span class="number">0.5</span>;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">+ (SDWebImageTransition *)fadeTransition &#123;</div><div class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</div><div class="line">    transition.animationOptions = <span class="built_in">UIViewAnimationOptionTransitionCrossDissolve</span> | <span class="built_in">UIViewAnimationOptionAllowUserInteraction</span>;</div><div class="line">    <span class="keyword">return</span> transition;</div><div class="line">&#125;</div><div class="line"></div><div class="line">+ (SDWebImageTransition *)flipFromTopTransition &#123;</div><div class="line">    SDWebImageTransition *transition = [SDWebImageTransition new];</div><div class="line">    transition.animationOptions = <span class="built_in">UIViewAnimationOptionTransitionFlipFromTop</span> | <span class="built_in">UIViewAnimationOptionAllowUserInteraction</span>;</div><div class="line">    <span class="keyword">return</span> transition;</div><div class="line">&#125;</div><div class="line"></div><div class="line">...</div></pre></div></div></figure></p>
<h1 id="WebCache-Categories"><a href="#WebCache-Categories" class="headerlink" title="WebCache Categories"></a>WebCache Categories</h1><p>这一部分的类有挺多我们平时使用<code>SDWebImage</code>库时用到的API，可以说是<code>SDWebImage</code>中我们最熟悉的部分。这一部分的分类不是工具类，更多的是对外API，也整合了整个库所有功能。这部分最主要的实现是在<code>UIView+WebCache</code>里，其他分类的API都是最后指向该分类的方法。每个分类也有其独特的地方，所以这些分类只记录它们特有的代码。</p>
<h2 id="UIButton-WebCache"><a href="#UIButton-WebCache" class="headerlink" title="UIButton+WebCache"></a>UIButton+WebCache</h2><p><code>UIButton</code>这个分类记录了每个状态state对应显示图片的URL。相关代码如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div></pre></div><div class="code"><pre><div class="line"><span class="meta">#pragma mark - API</span></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)sd_currentImageURL &#123;</div><div class="line">    <span class="built_in">NSURL</span> *url = <span class="keyword">self</span>.sd_imageURLStorage[imageURLKeyForState(<span class="keyword">self</span>.state)];</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (!url) &#123;</div><div class="line">        url = <span class="keyword">self</span>.sd_imageURLStorage[imageURLKeyForState(<span class="built_in">UIControlStateNormal</span>)];</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> url;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)sd_imageURLForState:(<span class="built_in">UIControlState</span>)state &#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">self</span>.sd_imageURLStorage[imageURLKeyForState(state)];</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="meta">#pragma mark - Private</span></div><div class="line">- (<span class="keyword">void</span>)sd_setBackgroundImageWithURL:(<span class="keyword">nullable</span> <span class="built_in">NSURL</span> *)url</div><div class="line">                            forState:(<span class="built_in">UIControlState</span>)state</div><div class="line">                    placeholderImage:(<span class="keyword">nullable</span> <span class="built_in">UIImage</span> *)placeholder</div><div class="line">                             options:(SDWebImageOptions)options</div><div class="line">                           completed:(<span class="keyword">nullable</span> SDExternalCompletionBlock)completedBlock &#123;</div><div class="line">    <span class="keyword">if</span> (!url) &#123;</div><div class="line">        [<span class="keyword">self</span>.sd_imageURLStorage removeObjectForKey:backgroundImageURLKeyForState(state)];</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">self</span>.sd_imageURLStorage[backgroundImageURLKeyForState(state)] = url;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    __<span class="keyword">weak</span> <span class="keyword">typeof</span>(<span class="keyword">self</span>)weakSelf = <span class="keyword">self</span>;</div><div class="line">    [<span class="keyword">self</span> sd_internalSetImageWithURL:url</div><div class="line">                    placeholderImage:placeholder</div><div class="line">                             options:options</div><div class="line">                        operationKey:backgroundImageOperationKeyForState(state)</div><div class="line">                       setImageBlock:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *imageData) &#123;</div><div class="line">                           [weakSelf setBackgroundImage:image forState:state];</div><div class="line">                       &#125;</div><div class="line">                            progress:<span class="literal">nil</span></div><div class="line">                           completed:completedBlock];</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (SDStateImageURLDictionary *)sd_imageURLStorage &#123;</div><div class="line">    SDStateImageURLDictionary *storage = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;imageURLStorageKey);</div><div class="line">    <span class="keyword">if</span> (!storage) &#123;</div><div class="line">        storage = [<span class="built_in">NSMutableDictionary</span> dictionary];</div><div class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;imageURLStorageKey, storage, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">return</span> storage;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h2 id="UIImageView-HighlightedWebCache"><a href="#UIImageView-HighlightedWebCache" class="headerlink" title="UIImageView+HighlightedWebCache"></a>UIImageView+HighlightedWebCache</h2><p>这个类的API都是最终指向<code>UIView+WebCache</code>的方法。</p>
<h2 id="UIImageView-WebCache"><a href="#UIImageView-WebCache" class="headerlink" title="UIImageView+WebCache"></a>UIImageView+WebCache</h2><p>这个分类添加了对动态图片处理的API，可以给定一个URL数组来设置动态图，会根据给定的URL数组加载图片最后生成动图。代码如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div></pre></div><div class="code"><pre><div class="line">- (<span class="keyword">void</span>)sd_setAnimationImagesWithURLs:(<span class="keyword">nonnull</span> <span class="built_in">NSArray</span>&lt;<span class="built_in">NSURL</span> *&gt; *)arrayOfURLs &#123;</div><div class="line">    [<span class="keyword">self</span> sd_cancelCurrentAnimationImagesLoad];</div><div class="line">    <span class="built_in">NSPointerArray</span> *operationsArray = [<span class="keyword">self</span> sd_animationOperationArray];</div><div class="line">    </div><div class="line">    [arrayOfURLs enumerateObjectsUsingBlock:^(<span class="built_in">NSURL</span> *logoImageURL, <span class="built_in">NSUInteger</span> idx, <span class="built_in">BOOL</span> * _Nonnull stop) &#123;</div><div class="line">        __<span class="keyword">weak</span> __<span class="keyword">typeof</span>(<span class="keyword">self</span>) wself = <span class="keyword">self</span>;</div><div class="line">        <span class="keyword">id</span> &lt;SDWebImageOperation&gt; operation = [[SDWebImageManager sharedManager] loadImageWithURL:logoImageURL options:<span class="number">0</span> progress:<span class="literal">nil</span> completed:^(<span class="built_in">UIImage</span> *image, <span class="built_in">NSData</span> *data, <span class="built_in">NSError</span> *error, SDImageCacheType cacheType, <span class="built_in">BOOL</span> finished, <span class="built_in">NSURL</span> *imageURL) &#123;</div><div class="line">            __<span class="keyword">strong</span> <span class="keyword">typeof</span>(wself) sself = wself;</div><div class="line">            <span class="keyword">if</span> (!sself) <span class="keyword">return</span>;</div><div class="line">            dispatch_main_async_safe(^&#123;</div><div class="line">                [sself stopAnimating];</div><div class="line">                <span class="keyword">if</span> (sself &amp;&amp; image) &#123;</div><div class="line">                    <span class="built_in">NSMutableArray</span>&lt;<span class="built_in">UIImage</span> *&gt; *currentImages = [[sself animationImages] mutableCopy];</div><div class="line">                    <span class="keyword">if</span> (!currentImages) &#123;</div><div class="line">                        currentImages = [[<span class="built_in">NSMutableArray</span> alloc] init];</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    <span class="comment">// We know what index objects should be at when they are returned so</span></div><div class="line">                    <span class="comment">// we will put the object at the index, filling any empty indexes</span></div><div class="line">                    <span class="comment">// with the image that was returned too "early". These images will</span></div><div class="line">                    <span class="comment">// be overwritten. (does not require additional sorting datastructure)</span></div><div class="line">                    <span class="keyword">while</span> ([currentImages count] &lt; idx) &#123;</div><div class="line">                        [currentImages addObject:image];</div><div class="line">                    &#125;</div><div class="line">                    </div><div class="line">                    currentImages[idx] = image;</div><div class="line"></div><div class="line">                    sself.animationImages = currentImages;</div><div class="line">                    [sself setNeedsLayout];</div><div class="line">                &#125;</div><div class="line">                [sself startAnimating];</div><div class="line">            &#125;);</div><div class="line">        &#125;];</div><div class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</div><div class="line">            [operationsArray addPointer:(__bridge <span class="keyword">void</span> *)(operation)];</div><div class="line">        &#125;</div><div class="line">    &#125;];</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p>通过<code>SDWebImageManager</code>来加载图片，因为加载图片的顺序是不确定的，会在先加载到排序靠后的图片时将该图片提前放入动画中，等到前面图片加载完成时再进行覆盖。这里<code>SDWebImage</code>处理不同URL组成动态图的方法有点简陋，没有将整个数组当成事务来处理，当其中有图片加载失败时，可能会呈现不完整的动态图（待测..）。<br>此外，还提供了取消操作的方法：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></div><div class="code"><pre><div class="line">- (<span class="built_in">NSPointerArray</span> *)sd_animationOperationArray &#123;</div><div class="line">    <span class="keyword">@synchronized</span>(<span class="keyword">self</span>) &#123;</div><div class="line">        <span class="built_in">NSPointerArray</span> *operationsArray = objc_getAssociatedObject(<span class="keyword">self</span>, &amp;animationLoadOperationKey);</div><div class="line">        <span class="keyword">if</span> (operationsArray) &#123;</div><div class="line">            <span class="keyword">return</span> operationsArray;</div><div class="line">        &#125;</div><div class="line">        operationsArray = [<span class="built_in">NSPointerArray</span> weakObjectsPointerArray];</div><div class="line">        objc_setAssociatedObject(<span class="keyword">self</span>, &amp;animationLoadOperationKey, operationsArray, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">        <span class="keyword">return</span> operationsArray;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line">- (<span class="keyword">void</span>)sd_cancelCurrentAnimationImagesLoad &#123;</div><div class="line">    <span class="built_in">NSPointerArray</span> *operationsArray = [<span class="keyword">self</span> sd_animationOperationArray];</div><div class="line">    <span class="keyword">if</span> (operationsArray) &#123;</div><div class="line">        <span class="keyword">@synchronized</span> (<span class="keyword">self</span>) &#123;</div><div class="line">            <span class="keyword">for</span> (<span class="keyword">id</span> operation <span class="keyword">in</span> operationsArray) &#123;</div><div class="line">                <span class="keyword">if</span> ([operation conformsToProtocol:<span class="class"><span class="keyword">@protocol</span>(<span class="title">SDWebImageOperation</span>)]) </span>&#123;</div><div class="line">                    [operation cancel];</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            operationsArray.count = <span class="number">0</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<h2 id="UIView-WebCache"><a href="#UIView-WebCache" class="headerlink" title="UIView+WebCache"></a>UIView+WebCache</h2><h1 id="Categories"><a href="#Categories" class="headerlink" title="Categories"></a>Categories</h1><h2 id="NSData-ImageContentType"><a href="#NSData-ImageContentType" class="headerlink" title="NSData+ImageContentType"></a>NSData+ImageContentType</h2><p>这个NSData分类负责解析图片数据格式类型。<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></div><div class="code"><pre><div class="line"><span class="comment">// 目前常用的图片格式类型</span></div><div class="line"><span class="keyword">typedef</span> <span class="built_in">NS_ENUM</span>(<span class="built_in">NSInteger</span>, SDImageFormat) &#123;</div><div class="line">    SDImageFormatUndefined = <span class="number">-1</span>,</div><div class="line">    SDImageFormatJPEG = <span class="number">0</span>,</div><div class="line">    SDImageFormatPNG,</div><div class="line">    SDImageFormatGIF,</div><div class="line">    SDImageFormatTIFF,</div><div class="line">    SDImageFormatWebP,</div><div class="line">    SDImageFormatHEIC</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">@interface</span> <span class="title">NSData</span> (<span class="title">ImageContentType</span>)</span></div><div class="line"></div><div class="line"><span class="comment">/** 解析传入NSData的图片类型 */</span></div><div class="line">+ (SDImageFormat)sd_imageFormatForImageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data;</div><div class="line"></div><div class="line"><span class="comment">/** 根据类型返回UIType。 */</span></div><div class="line">+ (<span class="keyword">nonnull</span> <span class="built_in">CFStringRef</span>)sd_UTTypeFromSDImageFormat:(SDImageFormat)format;</div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></pre></div></div></figure></p>
<p>区分图片类型的方式是通过各种格式的文件标识（file signature）来区分的，一般是放在文件数据的前几个字节。<br><img src="/images/image_format.png" alt="图片格式"><br>所以<code>+sd_imageFormatForImageData</code>方法的实现如下：<br><figure class="highlight objc"><div class="figcode"><div class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div></pre></div><div class="code"><pre><div class="line">+ (SDImageFormat)sd_imageFormatForImageData:(<span class="keyword">nullable</span> <span class="built_in">NSData</span> *)data &#123;</div><div class="line">    <span class="keyword">if</span> (!data) &#123;</div><div class="line">        <span class="keyword">return</span> SDImageFormatUndefined;</div><div class="line">    &#125;</div><div class="line">    </div><div class="line">    <span class="comment">// File signatures table: http://www.garykessler.net/library/file_sigs.html</span></div><div class="line">    uint8_t c;</div><div class="line">    [data getBytes:&amp;c length:<span class="number">1</span>];</div><div class="line">    <span class="keyword">switch</span> (c) &#123;</div><div class="line">        <span class="keyword">case</span> <span class="number">0xFF</span>:</div><div class="line">            <span class="keyword">return</span> SDImageFormatJPEG;</div><div class="line">        <span class="keyword">case</span> <span class="number">0x89</span>:</div><div class="line">            <span class="keyword">return</span> SDImageFormatPNG;</div><div class="line">        <span class="keyword">case</span> <span class="number">0x47</span>:</div><div class="line">            <span class="keyword">return</span> SDImageFormatGIF;</div><div class="line">        <span class="keyword">case</span> <span class="number">0x49</span>:</div><div class="line">        <span class="keyword">case</span> <span class="number">0x4D</span>:</div><div class="line">            <span class="keyword">return</span> SDImageFormatTIFF;</div><div class="line">        <span class="keyword">case</span> <span class="number">0x52</span>: &#123;</div><div class="line">            <span class="keyword">if</span> (data.length &gt;= <span class="number">12</span>) &#123;</div><div class="line">                <span class="comment">//RIFF....WEBP</span></div><div class="line">                <span class="built_in">NSString</span> *testString = [[<span class="built_in">NSString</span> alloc] initWithData:[data subdataWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">0</span>, <span class="number">12</span>)] encoding:<span class="built_in">NSASCIIStringEncoding</span>];</div><div class="line">                <span class="keyword">if</span> ([testString hasPrefix:<span class="string">@"RIFF"</span>] &amp;&amp; [testString hasSuffix:<span class="string">@"WEBP"</span>]) &#123;</div><div class="line">                    <span class="keyword">return</span> SDImageFormatWebP;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">        <span class="keyword">case</span> <span class="number">0x00</span>: &#123;</div><div class="line">            <span class="keyword">if</span> (data.length &gt;= <span class="number">12</span>) &#123;</div><div class="line">                <span class="comment">//....ftypheic ....ftypheix ....ftyphevc ....ftyphevx</span></div><div class="line">                <span class="built_in">NSString</span> *testString = [[<span class="built_in">NSString</span> alloc] initWithData:[data subdataWithRange:<span class="built_in">NSMakeRange</span>(<span class="number">4</span>, <span class="number">8</span>)] encoding:<span class="built_in">NSASCIIStringEncoding</span>];</div><div class="line">                <span class="keyword">if</span> ([testString isEqualToString:<span class="string">@"ftypheic"</span>]</div><div class="line">                    || [testString isEqualToString:<span class="string">@"ftypheix"</span>]</div><div class="line">                    || [testString isEqualToString:<span class="string">@"ftyphevc"</span>]</div><div class="line">                    || [testString isEqualToString:<span class="string">@"ftyphevx"</span>]) &#123;</div><div class="line">                    <span class="keyword">return</span> SDImageFormatHEIC;</div><div class="line">                &#125;</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">break</span>;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    <span class="keyword">return</span> SDImageFormatUndefined;</div><div class="line">&#125;</div></pre></div></div></figure></p>
<p>而<code>+sd_UTTypeFromSDImageFormat</code>通过一个switch case方法返回<code>SDImageFormat</code>对应的类型描述字符串。</p>
<h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><h1 id="未完待续…"><a href="#未完待续…" class="headerlink" title="未完待续…"></a>未完待续…</h1>
      
    </div>
    
    
    

    

     
      <div>
        <ul class="post-copyright">
  <li class="post-copyright-author">
    <strong>本文作者：</strong>
    
  </li>
  <li class="post-copyright-link">
    <strong>本文链接：</strong>
      <a href="https://xxxxxxgb.github.io/2018/05/26/SDWebImage/" title="读一读SDWebImage4">https://xxxxxxgb.github.io/2018/05/26/SDWebImage/</a>
  </li>
  <li class="post-copyright-license">
    <strong>温馨提示： </strong>
    <span class="tip">由于是原创文章，可能会有更新以及修正一些错误，因此转载请保留原出处，方便溯源，避免陈旧错误知识的误导，同时有更好的阅读体验。</span>
  </li>
</ul>

      </div>
    


    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/05/19/FBKVOController/" rel="next" title="读一读KVOController">
                <i class="fa fa-chevron-left"></i> 读一读KVOController
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
    


  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
    <div class="comments" id="comments">
      
        <div id="gitment-container"></div>
      
    </div>

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap" >
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">

            <canvas id='sidebar-author'></canvas>
            <a href="/"  class="site-author-image" rel="start" style="border: none;" title="">
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="" />
            </a>
            <p class="site-author-name" itemprop="name"></p>
            <p class="site-description motion-element" itemprop="description"></p>
        </div>

        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <!-- <a href="/archives/ || archive"> -->
              <a href="/archives">
                <span class="site-state-item-count">5</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          
            <div class="site-state-item site-state-categories"> 
              <!--  -->
              <a href="/categories">
                <span class="site-state-item-count">3</span>
                <span class="site-state-item-name">分类</span>
              <!--  -->
              </a>
            </div>
          

          

        </nav>

        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        <div id="sidebarClock" class="customFlipClock" style="height: 46px;width: 100%; ">TwentyFourHourClock</div>


      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#Decoder"><span class="nav-number">1.</span> <span class="nav-text">Decoder</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageFrame"><span class="nav-number">1.1.</span> <span class="nav-text">SDWebImageFrame</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageCoderHelper"><span class="nav-number">1.2.</span> <span class="nav-text">SDWebImageCoderHelper</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageCoder"><span class="nav-number">1.3.</span> <span class="nav-text">SDWebImageCoder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageImageIOCoder"><span class="nav-number">1.4.</span> <span class="nav-text">SDWebImageImageIOCoder</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageWebPCoder"><span class="nav-number">1.5.</span> <span class="nav-text">SDWebImageWebPCoder</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Cache"><span class="nav-number">2.</span> <span class="nav-text">Cache</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SDImageCacheConfig"><span class="nav-number">2.1.</span> <span class="nav-text">SDImageCacheConfig</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDImageCache"><span class="nav-number">2.2.</span> <span class="nav-text">SDImageCache</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化方法"><span class="nav-number">2.2.1.</span> <span class="nav-text">初始化方法</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#存储"><span class="nav-number">2.2.2.</span> <span class="nav-text">存储</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#查询"><span class="nav-number">2.2.3.</span> <span class="nav-text">查询</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#删除和清理"><span class="nav-number">2.2.4.</span> <span class="nav-text">删除和清理</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Dwonloader"><span class="nav-number">3.</span> <span class="nav-text">Dwonloader</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageDownloaderOperation"><span class="nav-number">3.1.</span> <span class="nav-text">SDWebImageDownloaderOperation</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化"><span class="nav-number">3.1.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#开始任务"><span class="nav-number">3.1.2.</span> <span class="nav-text">开始任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#收到回复"><span class="nav-number">3.1.3.</span> <span class="nav-text">收到回复</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接收图片数据"><span class="nav-number">3.1.4.</span> <span class="nav-text">接收图片数据</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接收完图片"><span class="nav-number">3.1.5.</span> <span class="nav-text">接收完图片</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取消任务"><span class="nav-number">3.1.6.</span> <span class="nav-text">取消任务</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageDownloader"><span class="nav-number">3.2.</span> <span class="nav-text">SDWebImageDownloader</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化-1"><span class="nav-number">3.2.1.</span> <span class="nav-text">初始化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#创建下载任务"><span class="nav-number">3.2.2.</span> <span class="nav-text">创建下载任务</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#取消任务-1"><span class="nav-number">3.2.3.</span> <span class="nav-text">取消任务</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Utils"><span class="nav-number">4.</span> <span class="nav-text">Utils</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageManager"><span class="nav-number">4.1.</span> <span class="nav-text">SDWebImageManager</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImagePrefetcher"><span class="nav-number">4.2.</span> <span class="nav-text">SDWebImagePrefetcher</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#SDWebImageTransition"><span class="nav-number">4.3.</span> <span class="nav-text">SDWebImageTransition</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#WebCache-Categories"><span class="nav-number">5.</span> <span class="nav-text">WebCache Categories</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#UIButton-WebCache"><span class="nav-number">5.1.</span> <span class="nav-text">UIButton+WebCache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UIImageView-HighlightedWebCache"><span class="nav-number">5.2.</span> <span class="nav-text">UIImageView+HighlightedWebCache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UIImageView-WebCache"><span class="nav-number">5.3.</span> <span class="nav-text">UIImageView+WebCache</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#UIView-WebCache"><span class="nav-number">5.4.</span> <span class="nav-text">UIView+WebCache</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Categories"><span class="nav-number">6.</span> <span class="nav-text">Categories</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#NSData-ImageContentType"><span class="nav-number">6.1.</span> <span class="nav-text">NSData+ImageContentType</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Reference"><span class="nav-number">7.</span> <span class="nav-text">Reference</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#未完待续…"><span class="nav-number">8.</span> <span class="nav-text">未完待续…</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder"></span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>








        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/function.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>


  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  <script type="text/javascript" src="/lib/zclip/clipboard.min.js"></script>	
<script type="text/javascript" src="/lib/flipclock/flipclock.min.js"></script>	
<script type="text/javascript" src="/js/src/customeFlipClock.js"></script>	
<script type="text/javascript" src="/js/src/codescrollbar.js"></script>	
<script type="text/javascript" src="/lib/tag3dCloud/tag3dCloud.min.js"> </script>
<script type="text/javascript" src="/lib/wobblewindow/wobblewindow.js"> </script>
<script type="text/javascript" src="/js/src/custom.js"></script>	
<script >
	$(document).ready(
	function()
		{			
			
		}
	);	
</script>
  


  




	





  





  







<!-- LOCAL: You can save these files to your site and update links -->
    
        
        <link rel="stylesheet" href="https://aimingoo.github.io/gitmint/style/default.css">
        <script src="https://aimingoo.github.io/gitmint/dist/gitmint.browser.js"></script>
    
<!-- END LOCAL -->

    

    
      <script type="text/javascript">
      function renderGitment(){
        var gitment = new Gitmint({
            id: window.location.pathname, 
            owner: 'xxxxxxgb',
            repo: 'https://github.com/xxxxxxgb/blog-comments.git',
            
            lang: "" || navigator.language || navigator.systemLanguage || navigator.userLanguage,
            
            oauth: {
            
            
                client_secret: '1e8c9abc6901b421808690eb1e3572708f8fd52c',
            
                client_id: 'ba95ef24632c5a4a4b28'
            }});
        gitment.render('gitment-container');
      }

      
      renderGitment();
      
      </script>
    







  





  

  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
